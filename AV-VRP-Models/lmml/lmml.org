#+AUTHOR: Claudia Porto Capetillo
#+AUTHOR: Fernando Raul Rodriguez Flores

* Description
  In this file I'm going to write (in a literate programming style) the source code for LMML: Lisp Mathematical Modelling Language.

  LMML is a Mathematical Modelling Language that can be used to write optimization programs.  It is originally aimed at linear programs, but that is not a constraint.

  After the model is written in LMML it can be exported to several backends.  Right now those backends are
  - GMPL,
  - LaTeX,
  - Pulp, and
  - Pyomo.

  In the first version of the literate programming we are going to reproduce exactly the same file structure that Claudia used in the original code.  That's the original structure of this file.

  There will be several layers of classes and constuctors.

  In the first layer all the constructors will be implemented with functions, and no infix processing.  In this layer there will be no optional parameters.  All parameters should be passed explicitly.

  In the second layer, we'll add some macros, but no infix processing.

  Finally, in the third layer, we'll add the infix processing, to make it look more like a traditional AML.

  All code written in this file will be in the package lmml-core.

  The idea is to add another package that uses this core, and it is the package where the user is expected to work.

  The first difference of that package is that we'll make it case-sensitive.

  
* file to load everything
** description
   In this section we'll add a file to load everything
** code
   #+begin_src lisp :results none :export code :tangle src/load-lmml.lisp
   (defun fload (filename)
     (let* ((dot-string (make-string (cl:- 40 (cl:+ 3 (length filename)))
                                     :initial-element #\.)))
       (format t "Loading ~a ..." filename)
       (load filename)
       (format t "~a OK~%" dot-string)))
   (fload "src/gagm.lisp")
   (fload "src/package.lisp")
   (fload "src/generic-functions.lisp")
   (fload "src/utilities.lisp")
   (fload "src/macros.lisp")
   (fload "src/reader-macros.lisp")
   (fload "src/infix-to-prefix.lisp")
   (fload "src/ast-nodes.lisp")
   (fload "src/basic-language.lisp")
   (fload "src/code-generation-utils.lisp")
   (fload "src/problem-examples.lisp")
   (fload "src/writer-gmpl.lisp")
   (fload "src/lmml-case-sensitivity.lisp")
   #+end_src


* package definition

** description
   In this section we define the package
** code
   #+begin_src lisp :results none :export code :tangle src/package.lisp
     (defpackage :lmml
       (:use :cl :gagm)
       (:shadow + - * / < <= > >= =
		set length) 
       
		
		)
       
   #+end_src


* utilities

** description
   In this section I'll add some basic utilities that will be used all over the system.

** declare the package in utilities.lisp
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/utilities.lisp
   (in-package :lmml)
   #+END_SRC

** symb,flatten and make-keyword
   
The first two utilities are symb and flatten.  The first one allows us to create symbols (useful for macro definitions), and flatten receives a tree and returns a flattened version of it.

# The following line is to add the ;;;{{{ delimiters to the tangle file

   #+BEGIN_SRC lisp :results none :exports none :tangle src/utilities.lisp
   ;;;{{{ symb and flatten
   #+END_SRC

*** mkstr and symb

   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
   (defun mkstr (&rest args)
     "Returns a string with the concatenation of the args"
     (string-upcase
      (with-output-to-string (s)
        (dolist (a args) (princ a s)))))

   (defun symb (&rest args)
     "Returns a symbol formed by the concatenation of the args."
     (values (intern (apply #'mkstr args))))
   #+END_SRC

*** flatten
    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
    (defun flatten (x)
      "Flattens a structure."
      (labels ((rec (x acc)
                 (cond ((null x) acc)
                       ((atom x) (cons x acc))
                       (t (rec (car x) (rec (cdr x) acc))))))
        (rec x nil)))
    #+END_SRC    


# The following line is to add the ;;;{{{ delimiters to the tangle file

#+BEGIN_SRC lisp :results none :exports none :tangle src/utilities.lisp
;;;}}}
#+END_SRC

*** make-keyword
    The idea is to create a keyword like =:name=.

    To make a keyword you just need to insert the symbol into the =:keyword= package.

    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
    (defun make-keyword (&rest args)
      (values (intern (apply #'mkstr args) :keyword)))
    #+END_SRC
    
** macro with-gensym
   The macro with-gensym:

    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
    ;;;{{{ with-gensym
    (defmacro with-gensyms (syms &body body)
      `(let ,(mapcar #'(lambda (s)
                         `(,s (gensym (symbol-name ',s))))
                       syms)
         ,@body))
    ;;;}}}
   #+END_SRC
** format-boxed
*** description
    This is a function very similar to format, but it prints two lines of `=', one above the format string and the other below.
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
   (defun format-boxed (stream format-str &rest format-args)
     (let* ((string-to-print
             (if format-args
                 (apply 'format `(nil ,format-str ,@format-args))
                 (funcall 'format nil format-str)))
            (length (cl:+ 2 (length string-to-print)))
            (=-line (make-string length :initial-element #\=)))
       (format stream "~a~% ~a~%~a~2%"
               =-line string-to-print =-line)))

   (setf (symbol-function 'bformat) #'format-boxed)
   #+END_SRC   
** symbol-downcase
   The idea is to return a downcase version of the symbol
*** code

    #+BEGIN_SRC lisp +n -r :results none :exports code :tangle src/utilities.lisp
    (defun symbol-downcase (symbol)
      (values (intern (string-downcase (symbol-name symbol)))))
    #+END_SRC
*** test
    #+begin_src lisp :results none :export code :tangle src/tests.lisp
    (let* ()
      (bformat t "Testing symbol-downcase")
      (format t "~a~%" (symbol-downcase 'hello))
      (format t "~a~%" (symbol-downcase 'HELLO))
      (format t "~a~%" (symbol-downcase 'hELLo)))
    #+end_src
** emacs-utils
*** description
    In this section I'll add the utilities to work with emacs.
*** code
   #+BEGIN_SRC emacs-lisp :results none :exports code :tangle emacs-utils.el
   ;; key to insert (load everything.lisp) in the repl
   (define-key lisp-mode-map (kbd "M-m M-o M-l")
     (lambda ()
       (interactive)
       (insert "(load \"src/load-lmml.lisp\") (in-package :lmml)")))

   (define-key lisp-mode-map (kbd "M-m M-o M-o")
     (lambda ()
       (interactive)
       (insert "(turn-off-case-sensitivity)") (slime-repl-return)))

   (define-key lisp-mode-map (kbd "M-m M-o M-i")
     (lambda ()
       (interactive)
       (insert "(turn-on-case-sensitivity)") (slime-repl-return)))

   (define-key lisp-mode-map (kbd "M-m M-o M-s")
        (lambda ()
          (interactive)
          (insert "(check-case-sensitivity)") (slime-repl-return)))
   #+END_SRC

   
* file generic-functions
  
** description
   This is a file where we'll write all the definitions of the generic-functions.

** add the package to the file
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/generic-functions.lisp
   (in-package :lmml)
   #+END_SRC


* TODO infix to prefix
  
** description
   In this section we'll add the functions required to convert an infix expression to a prefix expression.

** parameter *infix-ops*
*** description
    This is a list of lists with operators, the ones with highest precedence first.
*** code
   #+begin_src lisp :results none :export code :tangle src/infix-to-prefix.lisp
   (defparameter *infix-ops*
     '(((*) (/))
       ((+) (-))
       ((<) (>) (<=) (>=) (=))
       ((union) (inter) (diff) (cross)))
     "A list of lists of operators, highest precedence first.")
   #+end_src
** parameter *infix-ops-ast*
*** description
    This parameter maps the mathematical symbols used in the models to the corresponding ast-node constructor.
*** code
  #+begin_src lisp :results none :export code :tangle src/infix-to-prefix.lisp
  (defparameter *infix-ops-ast*
    (list (cons '+ 'add)
          (cons '- 'subs)
          (cons '* 'mult)
          (cons '/ 'div)
          (cons '+ 'add)
          (cons '< 'less)
          (cons '<= 'less-equal)
          (cons '> 'bigger)
          (cons '>= 'bigger-equal)
          (cons 'union 'union-op)
          (cons 'diff 'difference-op)
          (cons 'inter 'intersection-op)
          (cons 'cross 'cartesian-product-op)))
  #+end_src
** parameter *bin-ops-ast*
*** description
    This parameter lists the constructors of the binary operators used in the ast of the models.
*** code
  #+begin_src lisp :results none :export code :tangle src/infix-to-prefix.lisp
  (defparameter *bin-ops-ast*
    `(add subs mult div less less-equal bigger bigger-equal equal))
  #+end_src
** parameter *first-elements-of-ast-nodes*
*** description
    This parameter lists the names of the ast constructors that can be the first element of a list.
*** code
  #+begin_src lisp :results none :export code :tangle src/infix-to-prefix.lisp
  (defparameter *first-elements-of-ast-nodes*
    `(index-at sumf))
  #+end_src
** function is-arithmetic-expression
*** description
    This function returns t if the arg is a list in infix notation.

    For instance:

    `(1 + 2 * 3) should return t.
    `(add 2 6)   should return nil.
*** code
    #+begin_src lisp :results none :export code :tangle src/infix-to-prefix.lisp
    (defun is-aritmetic-expression (expr)
      "Returns t if expr is a list that does not start with the constructor of an arithmetic operator."
      (if (or (member (first expr) *bin-ops-ast*)
              (member (first expr) *first-elements-of-ast-nodes*))
          ;; then
          nil
          ;;else
          t))
    #+end_src
*** tests
    #+begin_src lisp :results none :export code :tangle tests/infix-to-prefix-tests.lisp
    (print (is-aritmetic-expression `(1 + 2 * 3)))
    (print (is-aritmetic-expression `(add 2 3)))
    (print (is-aritmetic-expression `(index-at X1 2 6)))
    (print (is-aritmetic-expression `(1)))
    #+end_src


* TODO generic functions
  
** description
   In this section I'm going to add some generic functions that we'll use in the code.

** length
*** description
    This function is a generalized length.  When called on strings or lists it calls the traditional length.  Otherwise it behaves conveniently.

*** generic-function
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/generic-functions.lisp
   (defgeneric length (obj)
     (:documentation "Returns the length of the given obj."))
   #+END_SRC

*** method for lists
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/utilities.lisp
    (defmethod length ((obj list))
      (cl:length obj))
    #+END_SRC
**** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (progn
        (bformat t "Testing length with lists")
        (format t "Expect 3: ~a~%" (length '(1 2 3)))
        (format t "Expect 2: ~a~%" (length '((1 2) 3))))
      #+end_src

*** method for strings
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/utilities.lisp
    (defmethod length ((obj string))
      (cl:length obj))
    #+END_SRC
**** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (progn
        (bformat t "Testing length with strings")
        (format t "Expect 5: ~a~%" (length "Hello"))
        (format t "Expect 0: ~a~%" (length ""))
        (format t "Expect 2: ~a~%" (length "hh")))
      #+end_src
*** method for symbols
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/utilities.lisp
    (defmethod length ((obj symbol))
      (cl:length (symbol-name obj)))
    #+END_SRC
**** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (progn
        (bformat t "Testing length with strings")
        (format t "Expect 5: ~a~%" (length 'Hello))
        (format t "Expect 3: ~a~%" (length 'one))
        (format t "Expect 11: ~a~%" (length 'hello-world)))
      #+end_src
*** method for nil
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/utilities.lisp
    (defmethod length ((obj (eql nil)))
      0)
    #+END_SRC
**** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (progn
        (bformat t "Testing length with strings")
        (format t "Expect 5: ~a~%" (length 'Hello))
        (format t "Expect 0: ~a~%" (length nil))
        (format t "Expect 0: ~a~%" (length nil)))
      #+end_src
*** method for numbers
**** code
    #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/utilities.lisp
    (defmethod length ((obj number))
      (cl:length (mkstr obj)))
    #+END_SRC
**** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (progn
        (bformat t "Testing length with numbers")
        (format t "Expect 5: ~a~%" (length 12345))
        (format t "Expect 1: ~a~%" (length 1))
        (format t "Expect 2: ~a~%" (length -1))
        (format t "Expect 8: ~a~%" (length -1.35e14)))
      #+end_src


* TODO macros
** description
   In this section we add the macros that will be used in the system.  All src blocks will be tangled to src/macros.lisp
** add the package to the file
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/macros.lisp
   (in-package :lmml)
   #+END_SRC
   
** make-binary-operations
*** description
    This macro encapsulates the creation of all the binary operations.  The macro receives a list where each element is a list with the name of an operation and a description.

    All classes will be created with the suffix =-op=.

    The following snippet:

    #+begin_src lisp :results none :exports code
    (make-binary-operations ((add "addition")
                             (subs "substraction")))
    #+end_src

    should expand into:
    #+begin_src lisp :results none :exports code
    (PROGN
      (DEFNODE ADD-OP (BINARY-OPERATION) NIL :DOCUMENTATION
               "Class representing the addition operation")
      (DEFNODE SUBS-OP (BINARY-OPERATION) NIL :DOCUMENTATION
               "Class representing the substraction operation"))
    #+end_src
*** code
    #+begin_src lisp :results none :export code :tangle src/macros.lisp
    (defmacro make-binary-operations (list-with-definitions)
      `(progn
         ,@(loop for (name operation-doc op) in list-with-definitions
                 for actual-name = (symb name '-op)
                 for print-obj-string = (format nil "(~a ~~a ~~a)" op)
                 collect `(progn
                            (defnode ,actual-name (binary-operation)
                              ()
                              :lambda-list (left right)
                              :string-obj (,print-obj-string left right)
                              :documentation ,(format nil "Class representing the ~a operation" operation-doc))))))
    #+end_src

*** test
**** testing macro expansion
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (make-binary-operations ((add "addition")
                             (subs "substraction")))  
      #+end_src

      Returns:

      #+begin_src lisp
      (PROGN
       (DEFNODE ADD-OP (BINARY-OPERATION) NIL :DOCUMENTATION
                "Class representing the addition operation")
       (DEFNODE SUBS-OP (BINARY-OPERATION) NIL :DOCUMENTATION
                "Class representing the substraction operation"))
      #+end_src
** make-binary-operations-layer-2-names
*** description
    This macro encapsulates the creation of the "common" names for the binary operations.  The macro receives a list where each element is a list with the name of an operation and the symbol that we should use for the constructor.

    I'll add the suffix =-op= to the name of all the classes

    The following snippet:

    #+begin_src lisp :results none :exports code
    (make-binary-operations-layer-2-names ((add +)
                                           (subs -)))
    #+end_src

    should expand into:
    #+begin_src lisp :results none :exports code
    (PROGN
      (defun + (left right)
        (add-op left right))
      (defun - (left right)
        (subs-op left right)))
    #+end_src
*** code
    #+begin_src lisp :results none :export code :tangle src/macros.lisp
    (defmacro make-binary-operations-layer-2-names (list-with-definitions)
      `(progn
         ,@(loop for (class-name operation) in list-with-definitions
                 for actual-name = (symb class-name '-op)
                 when operation
                 collect `(defun ,operation (left right)
                              (,actual-name left right)))))
    #+end_src

*** test
**** testing macro expansion
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (make-binary-operations-layer-2-names ((add +)
                                             (another nil)
                                             (subs -)))  
      #+end_src

      Returns:

      #+begin_src lisp
      (PROGN
        (DEFUN + (LEFT RIGHT) (ADD-OP LEFT RIGHT))
        (DEFUN - (LEFT RIGHT) (SUBS-OP LEFT RIGHT)))
      #+end_src
** generate-code-for-binary-operators according to language
*** description
    This macro receives a language, a list specifying the order of the operation and the operands, an a list with all the operations for which the code will be generated.

    Example:

    #+begin_src lisp :results none
    (generate-code-for-binary-operators infix-language
                                        "(~a) ~a (~a)"
                                        (left op right)
                                        ((add +)
                                         (subs -)))
    #+end_src
    
*** code
    #+begin_src lisp :results none :export code :tangle src/macros.lisp
    (defmacro generate-code-for-binary-operators
        (language format-string list-with-order list-with-operations)
      (let* ((left `(gcodenil left))
             (right `(gcodenil right))
             (defmethods-definitions
              (loop for (op symbol description)
                    in (if (symbolp list-with-operations)
                           (symbol-value list-with-operations)
                           list-with-operations)
                    for node-name = (symb op '-op)
                    for node-symbol = (symb op "-symbol")
                    for operator = `(generate-code (,node-symbol lang)
                                                   lang nil)
                    for actual-order = (loop for elt in list-with-order
                                             collecting (cond
                                                          ((eq elt 'op)
                                                           operator)
                                                          ((eq elt 'left) left)
                                                          ((eq elt 'right) right)))
                    for docstring = (format nil "Generate infix code for node ~a in language ~a."
                                            node-name
                                            language)
                    collecting `(defmethod generate-code ((node ,node-name)
                                                          (lang ,language)
                                                          stream)
                                  ,docstring
                                  (format stream ,format-string ,@actual-order)
                                  ))))
        ;; (format stream ,format-string ,@actual-order))))))
        `(progn
           ,@defmethods-definitions)))
    #+end_src
*** test
**** TODO testing macro expansion
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (generate-code-for-binary-operators infix-language
                                          "(~a) ~a (~a)"
                                          (left op right)
                                          ((add +)
                                           (another nil)
                                           (subs -)))  
      #+end_src

      Returns:

      #+begin_src lisp
      (PROGN
        (DEFMETHOD GENERATE-CODE ((NODE ADD-OP) (LANGUAGE INFIX-LANGUAGE) STREAM)
          "Generate infix code for node ADD-OP in language INFIX-LANGUAGE."
          (FORMAT STREAM "(~a) ~a (~a)" (GENERATE-CODE (LEFT NODE) LANGUAGE NIL)
                  (GENERATE-CODE (ADD-SYMBOL LANGUAGE) LANGUAGE NIL)
                  (GENERATE-CODE (RIGHT NODE) LANGUAGE NIL)))
        (DEFMETHOD GENERATE-CODE ((NODE ANOTHER-OP) (LANGUAGE INFIX-LANGUAGE) STREAM)
          "Generate infix code for node ANOTHER-OP in language INFIX-LANGUAGE."
          (FORMAT STREAM "(~a) ~a (~a)" (GENERATE-CODE (LEFT NODE) LANGUAGE NIL)
                  (GENERATE-CODE (ANOTHER-SYMBOL LANGUAGE) LANGUAGE NIL)
                  (GENERATE-CODE (RIGHT NODE) LANGUAGE NIL)))
        (DEFMETHOD GENERATE-CODE ((NODE SUBS-OP) (LANGUAGE INFIX-LANGUAGE) STREAM)
          "Generate infix code for node SUBS-OP in language INFIX-LANGUAGE."
          (FORMAT STREAM "(~a) ~a (~a)" (GENERATE-CODE (LEFT NODE) LANGUAGE NIL)
                  (GENERATE-CODE (SUBS-SYMBOL LANGUAGE) LANGUAGE NIL)
                  (GENERATE-CODE (RIGHT NODE) LANGUAGE NIL))))
      #+end_src
** generate-value-for-binary-operators
*** description
    This macro receives a list where each element is a list of length two.  The first is a the name of a binary-operator, and the second is the cl:operation that can evaluate that operator.  For instance, the first two elements of the list could be:

    '((add-op cl:+)
      (subs-op cl:-))

    If called with these arguments, it creates the method value for each of those classes, comining the values of left and right using the given cl:operator. 
*** code
    #+begin_src lisp :results none :export code :tangle src/macros.lisp
    (defmacro generate-value-for-binary-operators
        (list-with-data)
      (let* ((left `(value (left obj)))
             (right `(value (right obj)))
             (method-declarations
              (loop for (class op) in list-with-data
                    collecting `(defmethod value
                                    ((obj ,(symb class '-op)))
                                  (,op ,left ,right)))))

        `(progn
           ,@method-declarations)))
    #+end_src
*** test
**** testing macro expansion
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (generate-value-for-binary-operators
       ((add  cl:+)
        (subs cl:-)))  
      #+end_src

      Returns:

      #+begin_src lisp
      (PROGN
        (DEFMETHOD VALUE ((OBJ ADD-OP))
          (COMMON-LISP:+ (VALUE (LEFT OBJ)) (VALUE (RIGHT OBJ))))
        (DEFMETHOD VALUE ((OBJ SUBS-OP))
          (COMMON-LISP:- (VALUE (LEFT OBJ)) (VALUE (RIGHT OBJ)))))
      #+end_src
**** actual tests
    #+begin_src lisp :results none :export code :tangle src/tests.lisp
    (let* ((param-decl (parameter-declaration-node
                        "p1" :value 16))
           (p1 (param-ref "p1" param-decl))
           (node1 (add-op 1 3))
           (node2 (subs-op 1 3))
           (node3 (add-op p1 3)))

      (bformat t "Testing value for binary-ops")
      (format t "Value of +: ~2d~%" (value node1))
      (format t "Value of -: ~2d~%" (value node2))
      (format t "with param-ref: ~2d~%" (value node3))
      )
    #+end_src
** generate-current-value-for-binary-operators
*** description
    This macro receives a list where each element is a list of length two.  The first is a the name of a binary-operator, and the second is the cl:operation that can evaluate that operator.  For instance, the first two elements of the list could be:

    '((add-op cl:+)
      (subs-op cl:-))

    If called with these arguments, it creates the method value for each of those classes, combining the current-values of left and right using the given cl:operator. 
*** code
    #+begin_src lisp :results none :export code :tangle src/macros.lisp
    (defmacro generate-current-value-for-binary-operators
        (list-with-data)
      (let* ((left `(current-value (left obj)))
             (right `(current-value (right obj)))
             (method-declarations
              (loop for (class op) in list-with-data
                    collecting `(defmethod current-value
                                    ((obj ,(symb class '-op)))
                                  (,op ,left ,right)))))

        `(progn
           ,@method-declarations)))
    #+end_src
*** test
**** testing macro expansion
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (generate-value-for-binary-operators
       ((add  cl:+)
        (subs cl:-)))  
      #+end_src

      Returns:

      #+begin_src lisp
      (PROGN
        (DEFMETHOD VALUE ((OBJ ADD-OP))
          (COMMON-LISP:+ (VALUE (LEFT OBJ)) (VALUE (RIGHT OBJ))))
        (DEFMETHOD VALUE ((OBJ SUBS-OP))
          (COMMON-LISP:- (VALUE (LEFT OBJ)) (VALUE (RIGHT OBJ)))))
      #+end_src
**** actual tests
    #+begin_src lisp :results none :export code :tangle src/tests.lisp
    (let* ((param-decl (parameter-declaration-node
                        "p1" :value 16))
           (p1 (param-ref "p1" param-decl))
           (node1 (add-op 1 3))
           (node2 (subs-op 1 3))
           (node3 (add-op p1 3)))

      (bformat t "Testing value for binary-ops")
      (format t "Value of +: ~2d~%" (value node1))
      (format t "Value of -: ~2d~%" (value node2))
      (format t "with param-ref: ~2d~%" (value node3))
      )
    #+end_src


* TODO reader macros

** description

   In this section I'll add all the reader-macros used in lmml.  The src blocks will be tangled to reader-macros.lisp
** add the package to the file
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/reader-macros.lisp
   (in-package :lmml)
   #+END_SRC
** {} for set definition
*** description
    In this section I'm going to add a reader macro to be able to input a set using the braces.  I also want the content of the list to be evaluated.
    
*** code
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/reader-macros.lisp
   (defun open-brace-and-evaluate-macro-character (stream char1)
     (declare (ignore char1))
     `(list ,@(read-delimited-list #\} stream t)))

   (set-macro-character #\{ #'open-brace-and-evaluate-macro-character)
   (set-macro-character #\} (get-macro-character #\)))
   #+END_SRC

*** tests
    #+begin_src lisp :results none :export code :tangle src/tests.lisp
    (let* ((l1 {1 2 3})
           (l2 {1 (cl:+ 1 1) 3}))
      (bformat t "Testing reader macro for {}")
      (format t "l1: ~a~%" l1)
      (format t "l2: ~a~%" l2))
    #+end_src
** [] for index-at
*** description
    In this section I'm going to add a reader macro to input the indexes of an index-at using brackets.  With it, 
   (index-at 1 2) can be written as
   [1 2].

   Note that there is not a var or param reference inside the =index-at=.  It should be added in a posterior processing.

   Right now the macro just puts everything between the brackets inside a call to =index-at=.  This has the unexpected result that we can now write =(index-at x 1 2)= as =[x 1 2]=.  But that should only work if you are using the lispy interface.

*** code
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/reader-macros.lisp
   (defun open-bracket-macro-character (stream char)
     (declare (ignore char))
     `(index-at ,@(read-delimited-list #\] stream t)))


   (set-macro-character #\[ #'open-bracket-macro-character)
   (set-macro-character #\] (get-macro-character #\)))
   #+END_SRC

*** tests
    #+begin_src lisp :results none :export code :tangle src/tests.lisp
    (let* ()
      (bformat t "Testing reader macro for []")
      (format t "(index-at 1): ~a~%" `[1])
      (format t "(index-at 1 2): ~a~%" `[1 2])
      (format t "(index-at 1 2): ~a~%" `[1 (cl:+ 1 1)]))
    #+end_src


* TODO AST (code project)

** description
   In this section we'll add all the nodes required to create an optimization model.  We'll be using the functions and macros defined in gagm.

** add the package to the file name
   #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
   (in-package :lmml)
   #+end_src
** parameters
*** parameter *conjuntos*
**** description
     This list contains all data-set declared in the current model.

**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defparameter *conjuntos* nil)
     #+end_src
**** tests (no tests because it as a parameter)
*** parameter s.t.-name-counter
**** description
     A parameter to keep track of how many unnamed restrictions the user has declared in the model.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defparameter s.t.-name-counter 0)
     #+end_src
**** tests (no tests because it as a parameter)
** data-readers
*** description
    A data reader is a class to represent different ways to read data from different sources.

    The standard data-reader behaves in the following way:

      - for sets, it assumes that the elements is a list
      - for parameters,
        - if the parameter is a number, assume a number
        - if the parameter is indexed, 

           assume that the data is a list where each element is a list, according to the number of indexes the parameter has.

          For instance if we have a declaration of the form:
          (parameter P :domain {V})

          then we assume that the data is a list of elements.  The length of the list should be the cardinality of the set V, and we assume that each element in the list, correspond to the corresponding element in the set.

          If the parameter declaration is of the form:
          (parameter P :domain {V W})

          then we assume that the data is a list of lists.  The length of the outer list is the cardinality of the set V and the length of each inner-list should be the cardinality of W.

    If some user wants to use a different output for the data, the correct way to do it is to add another data-reader class and then specialize the corresponding generic-functions.
*** standard-data-reader
**** description
     The standard-data-reader was explained in the description of the data-readers section.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode standard-data-reader ()
       ()
       :string-obj ("<std-data-reader>"))
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((node (standard-data-reader)))
       (print node))
     #+end_src
**** constant
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defparameter +standard-data-reader+ (standard-data-reader))
     #+end_src
*** variable *current-data-reader*
**** description
     This variable will hold the value of the standard-data-reader.  Most of the time it will be hidden from the user.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defparameter *current-data-reader* +standard-data-reader+)
     #+end_src
** abstract classes
*** is-a-reference (abstract class)
**** description
     This is an abstract class for references.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode is-a-reference ()
       ()
       :documentation "Abstract class for references")
     #+end_src
**** tests (no tests because it is an abstract class)
*** has-name (abstract class)
**** description
     This is a base class for classes that have a name.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode has-name ()
       (name)
       :documentation "Base class for classes that have a name.")
     #+end_src
**** tests (no tests because it is an abstract class)
*** has-doc (abstract class)
**** description
     This is a base class for classes that have a documentation.  These should be the variable, parameters, and constraints.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode has-doc ()
       ((doc :documentation "A description for this element."))
       :documentation "Base class for classes that have a doc.")
     #+end_src
**** tests (no tests because it is an abstract class)
*** has-value (abstract class)
**** description
     This is a base class for classes that can have a value in the model.  These should be the sets and parameters.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode has-value ()
       ((value :documentation "The value(s) that this elements should have in the model"))
       :documentation "Base class for classes that can have a value.")
     #+end_src
**** tests (no tests because it is an abstract class)
*** has-current-value (abstract class)
**** description
     This is a base class for classes that can have a current-value in the model.  The difference between the =value= and the =current-value= is that the =value= is what the user passes as argument in the declaration.  And the =current-value= is the value the object has in a given time.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode has-current-value ()
       ((current-value :documentation "The current-value(s) that this element should have in the model"))
       :documentation "Base class for classes that can have a current-value.")
     #+end_src
**** tests (no tests because it is an abstract class)
*** has-domain (abstract class)
**** description
     This is a base class for classes that can have a domain in the model.  These should be the parameters and variables.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode has-domain ()
       ((domain :documentation "The domain where this elements should be indexed."))
       :documentation "Base class for classes that can be indexed over a domain.")
     #+end_src
**** tests (no tests because it is an abstract class)
*** has-original-declaration (abstract class)
**** description
     This is a base class for classes that have an original declaration.  This applies to the variables, parameters, and set references.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode has-original-declaration ()
       ((original-declaration :documentation "The original declaration that this class is a reference to."))
       :documentation "Base class for element references.")
     #+end_src
**** tests (no tests because it is an abstract class)
*** has-data-reader (abstract class)
**** description
     This is a base class for classes that can have data, and need to read it in some specific way.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode has-data-reader ()
       ((data-reader
         :documentation "The data-reader used to read the data."
         :initform (standard-data-reader)))
       :documentation "Base class for classes that require to read data.")
     #+end_src
**** tests (no tests because it is an abstract class)
*** quantifiers (abstract class) (not sure if needed)
**** description
     This is a base class for the quantifiers.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode quantifiers ()
       ()
       :documentation "A base class for the quantifiers.")
     #+end_src
**** tests (no tests because it is an abstract class)
*** binary-operation (abstract class)
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defabsnode binary-operation ()
       (left right)
       :documentation "Base class for the binary operations.")
     #+end_src
** actual classes
*** binary operations
**** description
     In this section we create the classes for all the binary-operations.  As they are all created in a similar way, we use the macro =make-binary-operations=.

     All the binary operations inherit the slots =left= and =right= from the class =binary-operation=.

     All the binary-operators will be created from the list in the following section
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (make-binary-operations ((add "addition" "+" +)
                              (subs "substraction" "-" -)
                              (mult "multiplication" "*" *)
                              (div "division" "/" /)
                              (less-than "less than" "<" <)
                              (less-or-equal "less than or equal to" "<=" <=)
                              (greater-than "greater than" ">" >)
                              (greater-or-equal "greater than or equal to" ">=" >=)
                              (assignment "assign operation" "setq")
                              (equality "equality operation" "=" =)
                              (union "set union" "U")
                              (intersection "set intersection" "^")
                              (difference "set difference" "\\")
                              (cartesian-product "set cartesian product" "x")))
     #+end_src
**** tests
***** simple test
****** description
       In this test I'm going to use a variable with all the possible operators.
****** list with data for the binary operators
       #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
       (defparameter list-with-operators-for-tests
         `((add "addition")
           (subs "substraction")
           (mult "multiplication")
           (div "division")
           (less-than "less than")
           (less-or-equal "less than or equal to")
           (greater-than "greater than")
           (greater-or-equal "greater than or equal to")
           (assignment "assign operation")
           (equality "equality operation")
           (union "set union")
           (intersection "set intersection")
           (difference "set difference")
           (cartesian-product "set cartesian product")))
       #+end_src
****** code
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (progn
         (bformat t "Testing binary-operators:")
         (loop for (op description) in list-with-operators-for-tests
               for node = (make-instance (symb op '-op) :left 1 :right 2)
               do (format t "Operation ~a:~38t ~a~%" description node)))
       #+end_src
**** code (added 2022-08-29)
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (make-binary-operations
      ((subset    "subset" "subset")
       (not-equal "not-equal" "not-equal")
       (belongs-to "belongs-to" "belongs-to")))
     #+end_src
**** tests
***** simple test
****** description
       In this test I'm going to use a variable with all the possible operators.
****** list with data for the binary operators
       #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
       (defparameter list-with-operators-for-tests-2
         `((subset    "subset")
           (not-equal "not-equal")
           (belongs-to "belongs-to")))
       #+end_src
****** code
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (progn
         (bformat t "Testing new binary-operators (2022-08-29):")
         (loop for (op description) in list-with-operators-for-tests-2
               for node = (make-instance (symb op '-op) :left 1 :right 2)
               do (format t "Operation ~a:~38t ~a~%" description node)))
       #+end_src
*** index-at
**** description
     This class represents a node to access an indexed element.  It has the "indexed" thing, and the desired index.

**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode index-at ()
       (var-name indexes)
       :lambda-list (var-name &rest indexes)
       :string-obj ("~a[~{~a~^ ~}]" var-name indexes))
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((node (index-at 'x 1 2 3 4)))
       (print node))
     #+end_src
*** for-all
**** description
     This class represents a for all quantifier.  It has an index name, a set name, and a predicate.

     It allows to create expressions as:
     (for-all i in I (where i is even))

     The pred slot is deprecated, because it has several drawbacks.  The idea is to allow the constraints to have several quantifers, and make the pred one of them.

**** (class definition)
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defnode for-all-quantifier (quantifiers)
        (var-name set-name pred)
        :lambda-list (var-name set-name &optional pred))

      (defmethod print-object ((obj for-all-quantifier) stream)
        (format stream "[forall ~a in ~a~a]"
                (var-name obj)
                (set-name obj)
                (if (pred obj) (format nil " where ~a"(pred obj)) "")))
      #+end_src
***** tests
****** simple test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((node (for-all-quantifier 'i 'J nil)))
         node)
       #+end_src
****** test with pred
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((node (for-all-quantifier 'i 'J (greater-than-op 'i 3))))
         (format t "forall with predicate:~% ~a~%" node))
       #+end_src
**** help functions
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defun is-a-for-all-quantifier (obj)
        (if (subtypep (class-of obj) 'for-all-quantifier)
            obj))

      (defun is-a-for-all-quantifier-list (obj)
        "A for-all-list is a list that start with `for-all-quantifier'"
        (if (and
             (symbolp (first obj))
             (eql (symbol-downcase (first obj))
                  (symbol-downcase 'for-all-quantifier)))
            obj))
      #+end_src
***** tests
****** testing is a for-all-quantifier
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((node (for-all-quantifier 'i 'J (greater-than-op 'i 3))))
         (bformat t "Testing is-a-for-all-quantifier")
         (format t "Expect non nil: ~a~%" (is-a-for-all-quantifier node))
         (format t "Expect nil:     ~a~%" (is-a-for-all-quantifier 5)))
       #+end_src
****** testing is a for-all-quantifier-list
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((node '(for-all-quantifier i J)))
         (bformat t "Testing is-a-for-all-quantifier-list")
         (format t "Expect non nil: ~a~%" (is-a-for-all-quantifier-list node))
         (format t "Expect nil:     ~a~%" (is-a-for-all-quantifier 5))
         (format t "Expect nil:     ~a~%" (is-a-for-all-quantifier-list
                                           '(for-all i in J))))
       #+end_src
*** var-in-set
**** description
     This class represents a sum indexing element where the variable should be in a given set
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode var-in-set ()
       (var-name
        set-name)
       :string-obj ("<~a in ~a>" var-name set-name))
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((node (var-in-set 'i 'K))
            (s1-decl (set-declaration-node "S1"))
            (s1 (set-ref "S1" s1-decl))
            (node2 (var-in-set 'i s1))
            )
       (bformat t "Testing var in set")
       (format t "i in K: ~a~%" node)
       (format t "i in S1: ~a~%" node2))
     #+end_src
*** var-from-to
**** description
     This class represents a sum indexing element defined by a lower and an upper bound.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode var-from-to ()
       (var-name
        from
        to)
       :string-obj ("<~a from ~a to ~a>" var-name from to))
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((node (var-from-to 'i 1 5))
            (node2 (var-from-to 'i 10 15)))
       (bformat t "Testing var from to")
       (format t "i from 1 to 5:   ~a~%" node)
       (format t "i from 10 to 15: ~a~%" node2))
     #+end_src
*** sum
**** description
***** version 2
      This class represent a summation.  A summation has a summation variable, a list with all the sum specification (using the classes var-in-set and var-from-to) and the elements that should be summed.

      If an expression contains a sum where there is more than one summation variable, the user should write 2 sums one inside the other.

      In the first layer, we'll only have a function as the constructor.

      In the second layer, we'll turn it into a macro and we'll create an variable reference for each variable in the sum-bounds.  We'll also have a better syntax with parenthesis around the keywords.

      The idea is to have something like:

      (sum ((i in I) (< i 5)
            (j in J) 
            (k in K) (< k j) (< k 8)
            (l from 1 to 6))

      In this case we assume that there are variables in lists where the second element is `in' or `from'.

***** +version 1+
      This class represent a summation.  A summation has a summation variable, a minimun and maximum value for the variable (or a set, containing all the possible values for the variable) and the elements that should be summed.

      If an expression contains a sum where there is more than one summation variable, the user should write 2 sums one inside the other.

      In the first layer, we'll only have a function as the constructor.

      In the second layer, we'll turn it into a macro and we'll create an variable reference from the given name.  We'll also have a better syntax with parenthesis around the keywords.
**** layer 1
***** version 2
****** code (layer 1)
       #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
       (defnode sum-node ()
         (sum-bounds
          elements)
         :string-obj ("(sum (~a) ~a)" sum-bounds elements))
       #+end_src
****** tests (layer 1)
******* simple-test
        #+begin_src lisp :results none :export code :tangle src/tests.lisp
        (let* ((node1 (sum-node (list (var-in-set 'i 'K))  (add-op 'i 2)))
               (node2 (sum-node (list (var-in-set 'i 'K)
                                      (var-in-set 'j 'K))
                                (add-op 'i 'j)))
               (node3 (sum-node (list (var-from-to 'i 10 15))
                                (add-op 'i 5)))
               (node4 (sum-node (list (var-from-to 'i 10 15)
                                      (var-in-set 'j 'K))
                                (add-op 'i 'j)))
               (node5 (sum-node (list (var-in-set 'i 'K)
                                      (< 'i 8))
                                (add-op 'i 1)))
               )
          (bformat t "Testing sum-node layer 1")
          (format t "var-in-set:  ~a~%" node1)
          (format t "2 sum-bounds ~a~%" node2)
          (format t "var-from-to  ~a~%" node3)
          (format t "2 types      ~a~%" node4)
          (format t "constraint   ~a~%" node5)
          )

        #+end_src
***** +version 1+
****** code (layer 1)
       #+begin_src lisp :results none :export code
       (defnode sum-node ()
         (var-name
          inf-value
          sup-value
          summation-set
          conditions-on-the-set
          elements)
         :lambda-list (var-name &key from to in conditions elements)
         :ctr-body (make-instance 'sum-node
                                  :var-name var-name
                                  :inf-value from
                                  :sup-value to
                                  :summation-set in
                                  :conditions-on-the-set conditions
                                  :elements elements))

       (defmethod print-object ((obj sum-node) stream)
         (let* ((set-or-not-set (summation-set obj)))
           (if set-or-not-set
               (format stream "(sum (~a in ~a~a) ~a)"
                       (var-name obj)
                       (summation-set obj)
                       (if (conditions-on-the-set obj)
                           (format nil " where ~a" (conditions-on-the-set obj))
                           "")
                       (elements obj))
               ;; else
               (format stream "(sum (~a from ~a to ~a) ~a)"
                       (var-name obj)
                       (inf-value obj)
                       (sup-value obj)
                       (elements obj)))))
       #+end_src
****** tests (layer 1)
******* simple-test
        #+begin_src lisp :results none :export code
        (let* ((node (sum-node 'i :from 1 :to 5 :elements  (add-op 'i 2)))
               (node2 (sum-node 'i :in 'J :elements 'i))
               (node3 (sum-node 'i :in 'J
                                :conditions (less-than-op 'i 5)
                                :elements 'i)))
          (format t "sum from to: ~a~%" node)
          (format t "sum in: ~a~%" node2)
          (format t "sum with conditions: ~a~%" node3)
          (format t "elements in node2: ~a~%" (elements node2)))

        #+end_src
**** layer 2
***** version 2
****** code (layer 2)
       #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
       (defmacro sumf ((&rest bounds) elements)
         ;; first let's collect all the variable names
         ;; and initialize the var-in-set and var-from-to classes
         (let* (var-refs
                bounds-initializations)

           (loop for bound in bounds
                 for symb = (second bound)
                 for var-name = (first bound)
                 do (progn
                      (cond
                        ;; if the second element is the symbol `in'
                        ((eql (symbol-downcase symb) (symbol-downcase 'in))
                         ;; it is a var-in-set clause
                         ;; let's collect the var name
                         (push `(,var-name (var-ref ',var-name)) var-refs)
                         ;; and push the constructor to the initializations 
                         (push `(var-in-set ,var-name ,(third bound))
                               bounds-initializations))
                        ;; if the second element is the symbol `from'
                        ((eql (symbol-downcase symb) (symbol-downcase 'from))
                         ;; it is a var-from-to clause
                         ;; let's collect the var-name
                         (push `(,var-name (var-ref ',var-name)) var-refs)
                         ;; and push the constructor to the initializations 
                         (push `(var-from-to ,var-name
                                             ,(third bound)
                                             ,(fifth bound))
                               bounds-initializations))
                        (t ;; it is neither a var-in-set nor var-from-to
                           ;; it should be a constraint so let's add it
                           ;; without any modifications
                         (push bound
                               bounds-initializations)))))

           `(let* ,(reverse var-refs)
              (make-instance 'sum-node
                             :sum-bounds ,(append `(list)
                                                  (reverse bounds-initializations))
                             :elements ,elements))))
       #+end_src
****** tests (layer 2)
******* simple-test
        #+begin_src lisp :results none :export code :tangle src/tests.lisp
        (let* ((j-decl (set-declaration-node "J"))
               (J (set-ref "J" j-decl))
               (node1 (sumf ((i in J)) (add-op i 2)))
               (node2 (sumf ((i in J) (k in J) ) (+ i k)))
               (node3 (sumf ((i in J) (< i 5) ) (+ i 2)))
               (node4 (sumf ((i from 1 to 5)) (add-op i 2)))
               (node5 (sumf ((i from 1 to 5)
                             (j from 1 to 10) )
                            (+ i j)))
               (node6 (sumf ((i from 1 to 10) (< i 5) ) (+ i 2)))
               )
          (bformat t "Testing var-in-set (layer 2)")
          (format t "One var:         ~a~%" node1)
          (format t "Two vars:        ~a~%" node2)
          (format t "A constraint:    ~a~%" node3)
          (terpri)
          (bformat t "Testing var-from-to (layer 2)")
          (format t "One var from     ~a~%" node4)
          (format t "Mixed bounds:    ~a~%" node5)
          (format t "Mixed and const: ~a~%" node6)
          )

        #+end_src
     
***** +version 1+
****** code (layer 2)
       #+begin_src lisp :results none :export code
       (defmacro sumf ((var-name &key from to in where) elements)
         `(let* ((,var-name (var-ref ',var-name)))
            (make-instance 'sum-node
                           :var-name ,var-name
                           :inf-value ,from
                           :sup-value ,to
                           :summation-set ,in
                           :conditions-on-the-set ,where
                           :elements ,elements)))
       #+end_src
****** tests (layer 2)
******* simple-test
        #+begin_src lisp :results none :export code
        (let* ((node (sumf (i :from 1 :to 5) (add-op i 2)))
               (node2 (sumf (i :in 'J) i))
               (node3 (sumf (i :in 'J :where (less-than-op i 5)) i))
               )
          (bformat t "Testing sum (layer 2)")
          (format t "sum from to: ~a~%" node)
          (format t "sum in: ~a~%" node2)
          (format t "sum with conds: ~a~%" node3)
          (format t "elements in node2: ~a~%" (elements node2))
          )

        #+end_src
     
*** constraint
**** description
     This class represent a constraint in an optimization model.  A constraint has an id, a function an an optional list with quantifiers.

     In the layer 1 all parameters should be passed explicitly even if they are nil.

     The next layers are the ones that should deal with those details
**** layer 1
***** code (layer 1)
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defnode constraint-node (has-doc)
        (id
         func
         quantifiers)
        :lambda-list (id func &key quantifiers doc))

      (defmethod print-object ((obj constraint-node) stream)
        (let* ()
          (format stream "[s.t. ~a: ~a~a~a]"
                      (id obj)
                      (func obj)
                      (if (quantifiers obj)
                          (format nil " ~a" (quantifiers obj))
                          "")
                      (if (doc obj)
                          (format nil " :doc ~a" (doc obj))
                          ""))))
      #+end_src
***** tests (layer 1)
****** simple-test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((node1 (constraint-node 1 (less-than-op 'x 5)))
              (node2 (constraint-node 2 (less-than-op 'x 5)
                                      :quantifiers
                                      (for-all-quantifier 'x 'Y nil)))
              (node3 (constraint-node 3 (less-than-op 'x 'z)
                                      :quantifiers
                                      (list
                                       (for-all-quantifier 'x 'Y nil)
                                       (for-all-quantifier 'z 'Y nil))))
              (node4 (constraint-node 4 (less-than-op 'x 'z)
                                      :quantifiers
                                      (for-all-quantifier 'x 'Y nil)
                                      :doc "A constraint"))
              (node5 (constraint-node 4 (less-than-op 'x 'z)
                                      :quantifiers
                                      (list
                                       (for-all-quantifier 'x 'Y nil)
                                       (< 'x 3))))
              )
         (bformat t "Testing constraint node")
         (format t "simple constranint: ~A~%" node1)
         (format t "constranint with:   ~A~%" node2)
         (format t "more quantifiers:   ~A~%" node3)
         (format t "documentation:      ~A~%" node4)
         (format t "additional cond:    ~A~%" node5))

       #+end_src
    
*** types of variables
**** description
      This class represents the type of a continuos variable.  It is a good idea to have the type of the variables as classes because that way we can generate the appropriate code for them polymorphically.

      We also define a parameter for each class that is the one that is going to be used.
**** continuous-variable-type
***** code
       #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
       (defnode continuous-variable-type ()
         ()
         :string-obj ("continuous"))
       (defparameter continuous-variable (make-instance 'continuous-variable-type))
       #+end_src
***** tests 
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ()
         (bformat t "Testing continuous-variable")
         (format t "~a~%" continuous-variable))

       #+end_src

**** integer-variable-type
***** code
       #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
       (defnode integer-variable-type ()
         ()
         :string-obj ("integer"))
       (defparameter integer-variable (make-instance 'integer-variable-type))
       #+end_src
***** tests
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ()
         (bformat t "Testing integer-variable")
         (format t "~a~%" integer-variable))

       #+end_src
**** binary-variable-type
***** code
       #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
       (defnode binary-variable-type ()
         ()
         :string-obj ("binary"))
       (defparameter binary-variable (make-instance 'binary-variable-type))
       #+end_src
***** tests
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ()
         (bformat t "Testing binary-variable")
         (format t "~a~%" binary-variable))

       #+end_src
*** variable reference
**** description
     This is a reference to a variable.  So far it has only a name.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode var-ref (is-a-reference
                       has-name
                       has-original-declaration)
       ()
       :lambda-list (name &optional original-declaration)
       :string-obj ("v_~a" name))
     #+end_src
**** tests
***** simple test
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (var-ref 'i))
             (node2 (var-ref 'i 'var-decl)))
        (bformat t "testing var ref")
        (format t "var-ref: ~a~%" node1)
        (format t "var-ref with var-decl: ~a~%" node2)
        (format t "var-decl: ~a~%" (original-declaration node2)))
      #+end_src
*** variable-declaration
**** description
     Here we define the node for a variable declaration.  When we declare a variable we need to define its
     - var-type (defaults to continuos),
     - lower-bounds (defaults to 0)
     - upper bounds (no default),
     - domain (for those cases where the variable is indexed.  It is inherited from has-domain.)
     - doc (in case we want to document the variable.  This slot is inherited from has-doc.)
     - value (this should be set by the solver).

     The slot value is suppossed to be set by the solver and the user should not set it.
**** layer 1
***** description
      In the layer 1 we only have a function with some named parameters.
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defnode variable-declaration-node (has-name
                                          has-doc
                                          has-domain)
        (value var-type lower-bound upper-bound)
        :lambda-list (name &key
                           (var-type continuous-variable)
                           (lower-bound 0)
                           (value nil)
                           upper-bound
                           doc
                           domain))

      (defmethod print-object ((obj variable-declaration-node) stream)
        (let* ()
          (format stream "[var-decl ~a: ~a~a~a~a]"
                      (name obj)
                      (var-type obj)
                      (if (and (numberp (lower-bound obj))
                               (/= (lower-bound obj) 0))
                          (format nil " >= ~a" (lower-bound obj))
                          "")
                      (if (numberp (upper-bound obj))
                          (format nil " <= ~a" (upper-bound obj))
                          "")
                      (if (domain obj)
                          (format nil " in ~a" (if (listp (domain obj))
                                                   (domain obj)
                                                   (list (domain obj))))
                          ""))))
      #+end_src
***** tests
****** simple-test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((node1 (variable-declaration-node 'x))
              (node2 (variable-declaration-node 'x :var-type binary-variable))
              (node3 (variable-declaration-node 'x :var-type integer-variable
                                                :lower-bound 1))
              (node4 (variable-declaration-node 'x :var-type binary-variable
                                                :lower-bound 1
                                                :upper-bound 10))
              (node5 (variable-declaration-node 'x :var-type integer-variable
                                                :lower-bound 1
                                                :upper-bound 10
                                                :domain 'H))
              (node6 (variable-declaration-node 'x :var-type continuous-variable
                                                :lower-bound 1
                                                :upper-bound 10
                                                :domain `(H H)))
              (node7 (variable-declaration-node 'x
                                                :var-type binary-variable
                                                :doc "A binary variable"))
              )
         (bformat t "Testing variable-declaration node")
         (format t "var decl:~20t ~A~%" node1)
         (format t "var decl with type:~20t ~A~%" node2)
         (format t "with lower-bound:~20t ~A~%" node3)
         (format t "with upper-bound:~20t ~A~%" node4)
         (format t "with domain:~20t ~A~%" node5)
         (format t "with domains:~20t ~A~%" node6)
         (format t "with doc:~20t ~A~%" (doc node7)))
       #+end_src
**** layer 2
***** description
      In the second layer we create the variable-reference besides creating the variable declaration node.  We also set the original-var slot of the reference to the variable-declaration.

      We want to be able to do something like:

      #+begin_src
      (variable-declaration x :lower-bound 10 :domain (J J))
      #+end_src
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defmacro variable-declaration (name &key
                                             (var-type continuous-variable)
                                             (lower-bound 0)
                                             upper-bound
                                             doc
                                             domain)
        `(let* ((var-decl (make-instance 'variable-declaration-node
                          :name ',name
                          :value nil
                          :var-type ,var-type
                          :lower-bound ,lower-bound
                          :upper-bound ,upper-bound
                          :doc ,doc
                          :domain ,domain)))
           (defparameter ,name
             (var-ref ',name var-decl))
           ;; return var-decl
           var-decl))
      #+end_src
***** tests
****** simple-test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
	 (let* ((node1 (variable-declaration x1))
		(node2 (variable-declaration x2
					     :var-type binary-variable))
		(node3 (variable-declaration x3
					     :var-type integer-variable
					     :lower-bound 1))
		(node4 (variable-declaration x4
					     :var-type binary-variable
					     :lower-bound 1
					     :upper-bound 10))
		(node5 (variable-declaration x5
					     :var-type integer-variable
					     :lower-bound 1
					     :upper-bound 10
					     :domain 'H))
		(node6 (variable-declaration x6
					     :var-type continuous-variable
					     :lower-bound 1
					     :upper-bound 10
					     :domain `(H H)))
		(node7 (variable-declaration x7
					     :var-type binary-variable
					     :doc "A binary variable."))
		)
	   (bformat t "Testing variable-declaration node")
	   (format t "var decl:~20t ~A~%" node1)
	   (format t "var decl with type:~20t ~A~%" node2)
	   (format t "with lower-bound:~20t ~A~%" node3)
	   (format t "with upper-bound:~20t ~A~%" node4)
	   (format t "with domain:~20t ~A~%" node5)
	   (format t "with domains:~20t ~A~%" node6)
	   (format t "with doc:~20t ~A~%" (doc node7))

	   (bformat t "Now testing the references")
	   (format t "~a: ~a~%" x1 (name x1))
	   (format t "~a: ~a~%" x2 (name x2))
	   (format t "~a: ~a~%" x3 (name x3))
	   (format t "~a: ~a~%" x4 (name x4))
	   (format t "~a: ~a~%" x5 (name x5))
	   (format t "~a: ~a~%" x6 (name x6))
	   (format t "~a: ~a~%" x7 (name x7))

	   (bformat t "Now testing the original-var in the references")
	   (format t "~a: ~a~%" x1 (original-declaration x1))
	   (format t "~a: ~a~%" x2 (original-declaration x2))
	   (format t "~a: ~a~%" x3 (original-declaration x3))
	   (format t "~a: ~a~%" x4 (original-declaration x4))
	   (format t "~a: ~a~%" x5 (original-declaration x5))
	   (format t "~a: ~a~%" x6 (original-declaration x6))
	   (format t "~a: ~a~%" x7 (original-declaration x7))
	   )
       #+end_src
*** objective function-node
**** description
     This class represents the objective function for the problem.

     It has three slots: an id, the function itself, and a documentation (inherited from has-doc).
**** code (layer 1)
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode objective-function-node (has-doc)
       (obj id func)
       :lambda-list (obj func &key id doc))
     #+end_src
**** tests
***** simple test
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (objective-function-node 'max 'function))
             (node2 (objective-function-node 'min 'function :id 1))
             (node3 (objective-function-node 'min 'function :id 1
                                             :doc "The obj function")))
        (bformat t "Testing obj-function")
        (format t "just basic:~% ~a~%" node1)
        (format t "with id:~% ~a~%" node2)
        (format t "with doc:~% ~a~%" node3))
      #+end_src
***** test with an actual function
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node (objective-function-node 1 (add-op (mult-op 2 'x)
                                                 (mult-op 4 'y)))))
        (print node))
      #+end_src
*** objective function to minimize
**** description
     This class represents an objective function that should be minimized.

     It has a new slot obj: a string with initform "minimize".
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defclass objective-function-for-minimization (objective-function-node)
       ((obj :initform "minimize")))

     (defun minimize (id func &key doc)
       (make-instance 'objective-function-for-minimization
                      :id id
                      :func func
                      :doc doc))

     (defmethod print-object ((obj objective-function-for-minimization)
                              stream)
       (format stream "[minimize (~a): ~a~a]"
               (id obj)
               (func obj)
               (if (doc obj)
                   (format nil " :doc ~a" (doc obj))
                   "")))
     #+end_src
**** tests
***** simple-test
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (minimize 1 'function))
             (node2 (minimize 2 'function))
             (node3 (minimize 3 'function
                              :doc "An obj function to minimize")))
        (bformat t "Testing obj-function")
        (format t "just basic:~% ~a~%" node1)
        (format t "with id:~% ~a~%" node2)
        (format t "with doc:~% ~a~%" node3))
      #+end_src
***** test with an actual function
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (minimize 
                     1 (add-op (mult-op 2 'x)
                               (mult-op 4 'y))))
             (node2 (minimize 
                     1 (add-op (mult-op 2 'x)
                               (mult-op 4 'y))
                     :doc "A basic function.")))
        (bformat t "Testing minimize with a function" )
        (format t "with-function:~30t ~a~%" node1)
        (format t "with-function and doc:~30t ~a~%" node2))
      #+end_src
      
*** objective function to maximize
**** description
     This class represents an objective function that should be maximized.

     It has a new slot obj: a string with initform "maximize".
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defclass objective-function-for-maximization (objective-function-node)
       ((obj :initform "maximize")))

     (defun maximize (id func &key doc)
       (make-instance 'objective-function-for-maximization
                      :id id
                      :func func
                      :doc doc))

     (defmethod print-object ((obj objective-function-for-maximization)
                              stream)
       (format stream "[maximize (~a): ~a~a]"
               (id obj)
               (func obj)
               (if (doc obj)
                   (format nil " :doc ~a" (doc obj))
                   "")))
     #+end_src
**** tests
***** simple-test
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (maximize 1 'function))
             (node2 (maximize 2 'function))
             (node3 (maximize 3 'function
                              :doc "An obj function to maximize")))
        (bformat t "Testing maximize")
        (format t "just basic:~% ~a~%" node1)
        (format t "with id:~% ~a~%" node2)
        (format t "with doc:~% ~a~%" node3))
      #+end_src
***** test with an actual function
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (maximize 
                     1 (add-op (mult-op 2 'x)
                               (mult-op 4 'y))))
             (node2 (maximize 
                     1 (add-op (mult-op 2 'x)
                               (mult-op 4 'y))
                     :doc "A basic function.")))
        (bformat t "Testing maximize with a function" )
        (format t "with-function:~30t ~a~%" node1)
        (format t "with-function and doc:~30t ~a~%" node2))
      #+end_src
      
*** instructions-list
**** description
     This class represents a list with instructions.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode instructions-list ()
       (elements)
       :documentation "An list with instructions.")
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (print (instructions-list (list 1 2 3 4)))
     #+end_src
*** problem-node
**** description
     This class represents a mathematical programming problem.  It has a list of instructions.
**** layer 1
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defnode problem-definition-node ()
        ((name) (instr)))

      (defmethod print-object ((obj problem-definition-node) stream)
        (format stream "problem: ~a~%~a~%"
                (name obj) (instr obj)))
      #+end_src
***** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((p1 (problem-definition-node "example 1" (list 1 2 3 4))))
        (format t "p1: ~a~%" p1))
      #+end_src
**** layer 2
***** description
      In thes layer we'll return the instructions in an instruction list.
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defun problem-node (name &rest instructions)
        (make-instance 'problem-definition-node
                       :name name
                       :instr (instructions-list instructions)))
      #+end_src
***** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((p1 (problem-node "example 1"  1 2 3 4)))
        (format t "p1: ~a~%" p1))
      #+end_src
**** layer 3
***** description
      In thes layer we'll return the instructions in an instruction list, and we'll create a variable with the ast of the problem
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defmacro problem (varname problem-name &rest instructions)
        `(defparameter ,varname
             (make-instance 'problem-definition-node
                           :name ,problem-name
                           :instr (instructions-list (list ,@instructions)))))
      #+end_src
***** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ()
        (problem p1 "example problem 1"
                 1 2 3 4)
        (format t "p1: ~a~%" p1))
      #+end_src
*** parameter reference
**** description
     This is a reference to a parameter.  So far it has only a name.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode param-ref (is-a-reference
                         has-name
                         has-original-declaration)
       ()
       :lambda-list (name &optional original-declaration)
       :string-obj ("p_~a" name))
     #+end_src
**** tests
***** simple test
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (param-ref  'i))
             (node2 (param-ref  'i 'original-declaration)))
        (bformat t "testing param ref")
        (format t "param-ref: ~a~%" node1)
        (format t "param-ref: ~a~%" node2)
        (format t "original-declaration: ~a~%" (original-declaration node2)))
      #+end_src
*** parameter-declaration
**** description
     Here we define the node for a parameter declaration.  When we declare a parameter we need to define its
     - name
     - domain (defaults to nil.  It is inherited from has-domain.)
     - doc (in case we want to document the parameter.  It is inherited from has-doc.)
     - value (in case we want to assign values to the parameter.  It is inherited from has-value.).
     - data-reader.  This is the data-reader used to read data for this parameter.  It defaults to =(standard-data-reader)=.
**** layer 1
***** description
      In the layer 1 we only have a function with some named parameters.
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defnode parameter-declaration-node (has-name
                                           has-doc
                                           has-value
                                           has-domain
                                           has-data-reader
                                           has-current-value)
        ()
        :lambda-list (name &key
                           domain
                           value
                           current-value
                           doc
                           (data-reader +standard-data-reader+)))

      (defmethod print-object ((obj parameter-declaration-node) stream)
        (let* ()
          (format stream "[param-decl ~a~a~a~a~a~a]"
                      (name obj)
                      (if (domain obj)
                          (format nil " ~a" (if (listp (domain obj))
                                                   (domain obj)
                                                   (list (domain obj))))
                          "")
                      (if (value obj)
                          (format nil " ~a" (value obj))
                          "")
                      (if (doc obj)
                          (format nil ": ~s" (doc obj))
                          "")
                      (if (not (eql (type-of (data-reader obj))
                                    'standard-data-reader))
                          (format nil ". reader: ~s" (data-reader obj))
                          "")
                      (if (current-value obj)
                          (format nil ". current: ~a"
                                  (current-value obj))
                          ""))))
      #+end_src
***** tests
****** simple-test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((node1 (parameter-declaration-node 'p))
              (node2 (parameter-declaration-node 'P :domain 'I))
              (node3 (parameter-declaration-node 'P :domain '(I J)))
              (node4 (parameter-declaration-node 'P :value 5))
              (node5 (parameter-declaration-node 'P :value 5
                                                 :doc "A documentation"))
              (node6 (parameter-declaration-node 'P :value 5
                                                 :data-reader 8))
              (node7 (parameter-declaration-node 'P :value 5
                                                 :data-reader 8
                                                 :current-value 15))
              (tab-pos 25))
  
         (bformat t "Testing parameter-declaration node")
         (format t "param decl:~vt ~A~%" tab-pos node1)
         (format t "param decl with domain:~vt ~A~%" tab-pos node2)
         (format t "with two indexes:~vt ~A~%" tab-pos node3)
         (format t "with value:~vt ~A~%" tab-pos node4)
         (format t "with value and doc:~vt ~A~%" tab-pos node5)
         (format t "with value and doc:~vt ~A~%" tab-pos node6)
         (format t "with value and doc:~vt ~A~%" tab-pos node7))
       #+end_src
**** layer 2
***** description
      In the second layer we create the parameter-reference besides creating the variable declaration node.  

      We want to be able to do something like:

      #+begin_src
      (param-declaration x :lower-bound 10 :domain (J J))
      #+end_src
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defmacro parameter (name &key
                                  domain
                                  doc
                                  value
                                  (data-reader +standard-data-reader+))
        `(let* ((param-declaration
                 (make-instance 'parameter-declaration-node
                                :name ',name
                                :value ,value
                                :current-value ,value
                                :doc ,doc
                                :domain ,domain
                                :data-reader ,data-reader)))
           (defparameter ,name
             (param-ref ',name param-declaration))
           ;; return the declaration
           param-declaration))
      #+end_src
***** tests
****** simple-test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((node1 (parameter P1))
              (node2 (parameter P2 :domain 'I))
              (node3 (parameter P3 :domain '(I J)))
              (node4 (parameter P4 :value 5))
              (node5 (parameter P5 :value 5
                                :doc "A documentation"))
              (node6 (parameter P6 :value 5
                                :data-reader 8))
              )
         (bformat t "Testing parameter-declaration macro")
         (format t "param decl:~40t ~A~%" node1)
         (format t "param decl with domain:~40t ~A~%" node2)
         (format t "with two indexes:~40t ~A~%" node3)
         (format t "with value:~40t ~A~%" node4)
         (format t "with documentation:~40t ~A~%" node5)
         (format t "with data-reader:~40t ~A~%" node6)

         (bformat t "Now testing the param-refs")
         (format t "P1: ~a~%" p1)
         (format t "P2: ~a~%" p2)
         (format t "P3: ~a~%" p3)
         (format t "P4: ~a~%" p4)
         (format t "P5: ~a~%" p5)
         (format t "P6: ~a~%" p6)

         (bformat t "Testing the original-declaration")
         (format t "P1: ~a~%" (original-declaration p1))
         (format t "P2: ~a~%" (original-declaration p2))
         (format t "P3: ~a~%" (original-declaration p3))
         (format t "P4: ~a~%" (original-declaration p4))
         (format t "P5: ~a~%" (original-declaration p5))
         (format t "P6: ~a~%" (original-declaration p6))
         )
       #+end_src
*** range-node
**** description
     Here we create a range to define set as in 1..5.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode range-node ()
       (min-value max-value increment)
       :lambda-list (min-value max-value &key (increment 1))
       :ctr-name range
       :string-obj ("[~a..~a by ~a]" min-value max-value increment))
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((node1 (range 1 5))
            (node2 (range 1 5 :increment 2)))
       (bformat t "Testing range-node")
       (format t "range: ~a~%" node1)
       (format t "range: ~a~%" node2))
     #+end_src
*** set reference
**** description
     This is a reference to a set.  So far it has only a name.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode set-ref (is-a-reference
                       has-name
                       has-original-declaration)
       ()
       :lambda-list (name &optional original-declaration)
       :string-obj ("S_~a" name))
     #+end_src
**** tests
***** simple test
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (set-ref  'I))
             (node2 (set-ref  'I 'original)))
        (bformat t "testing set ref")
        (format t "set-ref: ~a~%" node1)
        (format t "set-ref: ~a~%" node2)
        (format t "original: ~a~%" (original-declaration node2)))
      #+end_src
*** set-declaration
**** description
     Here we define the node for a set declaration.  When we declare a parameter we need to define its
     - name
     - dimension
     - doc (in case we want to document the set.  It inherits this slot from the has-doc class.)
     - value (in case we want to assign values to the set.  It is inherited from has-value).
     - data-reader.  This is the data-reader used to read data for this set.  It defaults to =(standard-data-reader)=.
**** layer 1
***** description
      In the layer 1 we only have a function with some named parameters.
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defnode set-declaration-node (has-name
                                     has-doc
                                     has-value
                                     has-data-reader
                                     has-current-value)
        (dimension)
        :lambda-list (name &key
                           dimension
                           value
                           current-value
                           doc
                           (data-reader +standard-data-reader+)))

      (defmethod print-object ((obj set-declaration-node) stream)
        (let* ()
          (format stream "[set-decl ~a~a~a~a~a~a]"
                      (name obj)
                      (if (dimension obj)
                          (format nil " [~a]" (dimension obj))
                          "")
                      (if (value obj)
                          (format nil ", v: ~a" (value obj))
                          "")
                      (if (doc obj)
                          (format nil ", ~s" (doc obj))
                          "")
                      (if (not (eql (type-of (data-reader obj))
                                          'standard-data-reader))
                                (format nil ". reader: ~s" (data-reader obj))
                                "")
                      (if (current-value obj)
                          (format nil ". current: ~a" (current-value obj))
                          ""))))
      #+end_src
***** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (set-declaration-node 'S))
             (node2 (set-declaration-node 'S :dimension 2))
             (node3 (set-declaration-node 'S :value '(1 2 3)))
             (node4 (set-declaration-node 'S :value '(1 2 3)
                                          :doc "A set documentation"))
             (node5 (set-declaration-node 'S :value (list (range 1 3))))
             (node6 (set-declaration-node 'S :data-reader 8))
             (node7 (set-declaration-node 'S :data-reader 8 :current-value 19))

             (tab-pos 27))

        (bformat t "Testing set-declaration node")
        (format t "param decl:~vt ~A~%" tab-pos node1)
        (format t "param decl with domain:~vt ~A~%" tab-pos node2)
        (format t "with two indexes:~vt ~A~%" tab-pos node3)
        (format t "with value and doc:~vt ~A~%" tab-pos  node4)
        (format t "with range in values:~vt ~A~%" tab-pos node5)
        (format t "with data-reader:~vt ~A~%" tab-pos node6)
        (format t "with data-reader:~vt ~A~%" tab-pos node7))
      #+end_src
**** layer 2
***** description
      In the second layer we create the set-reference besides creating the set-declaration node.  

      We want to be able to do something like:

      #+begin_src
      (set-declaration I :set-doc "The vertices.")
      #+end_src
***** code
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defmacro set (name &key
                            dimension
                            value
                            doc
                            (data-reader +standard-data-reader+))
        `(let* ((set-declaration
                 (make-instance 'set-declaration-node
                                :name ',name
                                :dimension ,dimension
                                :value ,value
                                :current-value ,value
                                :doc ,doc
                                :data-reader ,data-reader)))
           (defparameter ,name
             (set-ref ',name set-declaration))
           ;; return the set-declaration
           set-declaration))
      #+end_src
***** tests
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((node1 (set S1))
             (node2 (set S2 :dimension 2))
             (node3 (set S3 :value '(1 2 3)))
             (node4 (set S4 :value '(1 2 3)
                         :doc "A set documentation"))
             (node5 (set S5 :value (range 1 3)
                         :data-reader 8)))

        (bformat t "Testing set-declaration macro")
        (format t "set decl:~40t ~A~%" node1)
        (format t "set decl with domain:~40t ~A~%" node2)
        (format t "with two indexes:~40t ~A~%" node3)
        (format t "with value:~40t ~A~%" node4)
        (format t "with data reader:~40t ~A~%" node5)

        (bformat t "Now testing the set-refs")
        (format t "S1: ~a~%" S1)
        (format t "S2: ~a~%" S2)
        (format t "S3: ~a~%" S3)
        (format t "S4: ~a~%" S4)
        (format t "S5: ~a~%" S5)

        (bformat t "Testing the original-ref")
        (format t "S1: ~a~%" (original-declaration S1))
        (format t "S2: ~a~%" (original-declaration S2))
        (format t "S3: ~a~%" (original-declaration S3))
        (format t "S4: ~a~%" (original-declaration S4))
        (format t "S5: ~a~%" (original-declaration S5))
        )
      #+end_src
*** display-node
**** description
     Here we create a node for the operation display.  In this first version, it only receives an element to display.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode display-node ()
       (element)
       :ctr-name display
       :string-obj ("[display ~a]" element))
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((v (var-ref "x"))
            (node1 (display 1))
            (node2 (display v))
            (node3 (display (+ 1 v))))
       (bformat t "Testing display-node")
       (format t "~a~%" node1)
       (format t "~a~%" node2)
       (format t "~a~%" node3))
     #+end_src
*** solve-node
**** description
     Here we create a node for the solve operation.  This node receives no arguments.
**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode solve-node ()
       ()
       :ctr-name solve
       :string-obj ("[solve]"))
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((node1 (solve)))
       (bformat t "Testing solve-node")
       (format t "~a~%" node1))
     #+end_src
*** set-value-of-param
**** description
     This operation represents the action of setting the value of a given parameter.  This can be done after the parameter was created.  For instance, in GMPL, this is done in the DATA section.

     To read the data, we'll create some classes called data-reader, and a generic function that specializes on each specific type of input.

     The first argument to this node should be a param-ref with a non nil  original-declaration.

**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode set-value-of-param ()
       (param-name value data-reader)
       :lambda-list (param-name value &optional
                                (data-reader +standard-data-reader+))
       :ctr-body (progn
                   (setf (current-value (original-declaration param-name))
                         value
                         (data-reader (original-declaration param-name))
                         data-reader)
                   make-ctr))

     (defmethod print-object ((node set-value-of-param) stream)
       (format stream "(set-value-of-param ~a to: ~a~a)"
               (param-name node)
               (value node)
               (if (not (eql (type-of (data-reader node))
                             'standard-data-reader))
                   (format nil ". reader: ~a" (data-reader node))
                   "")
               ))
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl-1 (parameter-declaration-node "P"))
            (p (param-ref "P" param-decl-1))
            (node1 (set-value-of-param p 5))
            (node2 (set-value-of-param p 5 8))
            (node3 nil)
            )
       (bformat t "Testing set-value-of-param")
       (format t "~a~%" p)
       (format t "~a~%" node1)
       (format t "~%Setting a value:~%")
       (format t "value of original declaration (should be nil): ~a~%"
               (value (original-declaration p)))
       (format t "current-value of original declaration (non nil): ~a~%"
               (current-value (original-declaration p)))
       (format t "~a~%" node2)

       (format t "~%setting a list:~%")
       (setf node3 (set-value-of-param p '(1 2 3 4)))
       (format t "~a~%" node3)
       (format t "value of original declaration (should be nil): ~a~%"
               (value (original-declaration p)))
       (format t "current-value of original declaration (non nil): ~a~%"
               (current-value (original-declaration p)))
       )
     #+end_src
*** set-value-of-set
**** description
     This operation represents the action of setting the value of a given set.  This can be done after the set was created.  For instance, in GMPL this is done in the DATA section.

     To read the data, we'll create some classes called data-reader, and a generic function that specializes on each specific type of input.  This function will be used in the code generation.

     The first argument to this node should be a set-ref with a non nil  original-declaration.

**** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (defnode set-value-of-set ()
       (set-name value data-reader)
       :lambda-list (set-name value &optional
                                (data-reader +standard-data-reader+))
       :ctr-body (progn
                   (setf (current-value (original-declaration set-name))
                         value
                         (data-reader (original-declaration set-name))
                         data-reader)
                   make-ctr))

     (defmethod print-object ((node set-value-of-set) stream)
       (format stream "(set-value-of-set ~a to: ~a~a)"
               (set-name node)
               (value node)
               (if (not (eql (type-of (data-reader node))
                             'standard-data-reader))
                   (format nil ". reader: ~a" (data-reader node))
                   "")))
     #+end_src
**** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((set-decl-1 (set-declaration-node "S"))
            (p (set-ref "S" set-decl-1))
            (node1 (set-value-of-set p 5))
            (node2 (set-value-of-set p 5 8))
            (node3 nil)
            (node4 nil)
            )
       (bformat t "Testing set-value-of-set")
       (format t "~a~%" p)
       (format t "~a~%" node1)

       (format t "~%Setting a value:~%")
       (format t "value of original declaration (expect nil): ~a~%"
               (value (original-declaration p)))
       (format t "current-value of original declaration (non nil): ~a~%"
               (current-value (original-declaration p)))
       (format t "The assignment: ~a~%" node2)

       (format t "~%Setting a list:~%")
       (setf node3 (set-value-of-set p '(1 2 3 4)))
       (format t "~a~%" node3)
       (format t "value of original declaration (expect nil): ~a~%"
               (value (original-declaration p)))
       (format t "current-value of original declaration (non nil): ~a~%"
               (current-value (original-declaration p)))

       (format t "~%Setting a range:~%")
       (setf node4 (set-value-of-set p (range 1 5)))
       (format t "~a~%" node4)
       (format t "value of original declaration (expect nil): ~a~%"
               (value (original-declaration p)))
       (format t "current-value of original declaration (non nil): ~a~%"
               (current-value (original-declaration p))))
     #+end_src
*** data-section
**** description
     This class represents the data section in languages where you can split the problem into the model and the data.  It just has a list of elements.
**** code
***** layer 1
****** code
       #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
       (defnode data-section-node ()
         (instr)
         :lambda-list (&rest instr))

       (defun is-a-data-section (obj)
         "If arg is a data section, return it."
         (if (subtypep (class-of obj) 'data-section-node)
             obj))

       (defmethod print-object ((node data-section-node) stream)
         (format stream "[~adata section~a~{~a~^, ~}]"
                 (if (or
                      (and
                       (listp (instr node))
                       (null (instr node)))
                      (and
                       (subtypep (class-of (instr node)) 'instructions-list)
                       (null (elements (instr node)))))
                     "Empty " "")
                 (if (or
                      (and
                       (listp (instr node))
                       (null (instr node)))
                      (and
                       (subtypep (class-of (instr node)) 'instructions-list)
                       (null (elements (instr node)))))
                     "" ": ")
                 (mapcar (lambda (x)
                           (name x))
                         (if (listp (instr node))
                             (instr node)
                             (elements (instr node))))))
       #+end_src
****** tests layer 1
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((p1-decl (parameter-declaration-node "p"))
              (p1 (param-ref "p" p1-decl))
              (s-decl (set-declaration-node "S"))
              (s (set-ref "S" s-decl))
              (node1 (data-section-node))
              (set-p (set-value-of-param p1 5))
              (node2 (data-section-node set-p))
              (set-s (set-value-of-set s '(1 2 3)))
              (node3 (data-section-node set-s))
              (node4 (data-section-node set-p set-s))
              )
         (bformat t "Testing data")
         (format t "~a~%" node1)
         (format t "~a~%" node2)
         (format t "~a~%" node3)
         (format t "~a~%" node4)
         (bformat t "Testing is-a-data-section")
         (format t "Expect non nil: ~a~%" (is-a-data-section node1))
         (format t "Expect non nil: ~a~%" (is-a-data-section node4))
         (format t "Expect     nil: ~a~%" (is-a-data-section 5))
         (format t "Expect     nil: ~a~%" (is-a-data-section s)))

       #+end_src
***** layer 2
****** code
       #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
       (defun data-section (&rest instructions)
         (make-instance 'data-section-node
                        :instr (instructions-list instructions)))
       #+end_src
****** tests layer 2
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((p1-decl (parameter-declaration-node "p"))
              (p1 (param-ref "p" p1-decl))
              (s-decl (set-declaration-node "S"))
              (s (set-ref "S" s-decl))
              (node1 (data-section))
              (set-p (set-value-of-param p1 5))
              (node2 (data-section set-p))
              (set-s (set-value-of-set s '(1 2 3)))
              (node3 (data-section set-s))
              (node4 (data-section set-p set-s))
              )
         (bformat t "Testing data")
         (format t "~a~%" node1)
         (format t "~a~%" node2)
         (format t "~a~%" node3)
         (format t "~a~%" node4))

       #+end_src


* TODO language improvements over basic constructors
** description
   In this section we add the syntactic elements that will improve the language over the basic constructors.

   All the infix-to-prefix stuff should be in this section.
** binary-operations (layer 2)
*** description
    In this section we add the corresponding names to the binary-operation constructors.
*** code
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (make-binary-operations-layer-2-names
      ((add +)
       (subs -)
       (mult *)
       (div /)
       (less-than <)
       (less-or-equal <=)
       (greater-than >)
       (greater-or-equal >=)
       (assignment nil)
       (equality =)
       (union nil)
       (intersection nil)
       (difference nil)
       (cartesian-product nil)))
     #+end_src
*** tests
**** simple test
***** description
      In this test I'm going to use a variable with all the possible operators.
***** list with data for the binary operators
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defparameter list-with-operators-for-tests-layer-2
        `((add "addition" +)
          (subs "substraction" - )
          (mult "multiplication" *)
          (div "division" /)
          (less-than "less than" <)
          (less-or-equal "less than or equal to" <=)
          (greater-than "greater than" >)
          (greater-or-equal "greater than or equal to" >=)
          (assignment "assign operation" nil)
          (equality "equality operation" =)
          (union "set union" nil)
          (intersection "set intersection" nil)
          (difference "set difference" nil)
          (cartesian-product "set cartesian product" nil)))
      #+end_src
***** code
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (progn
        (bformat t "Testing binary-operators layer 2:")
        (format t "Add:~6t ~a~%"  (+ 1 2))
        (format t "subs:~6t ~a~%" (- 1 2))
        (format t "mult:~6t ~a~%" (* 1 2))
        (format t "div:~6t ~a~%"  (/ 1 2))
        (format t "<:~6t ~a~%"    (< 1 2))
        (format t "<=:~6t ~a~%"   (<= 1 2))
        (format t ">:~6t ~a~%"    (> 1 2))
        (format t ">=:~6t ~a~%"   (>= 1 2))
        (format t "=:~6t ~a~%"    (= 1 2))
        )
      #+end_src
*** code (new operations 2022-08-29)
     #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
     (make-binary-operations-layer-2-names
      ((subset subset)
       (not-equal !=)
       (belongs-to in)))
     #+end_src
*** tests
**** simple test
***** description
      In this test I'm going to use a variable with all the possible operators.
***** list with data for the binary operators
      #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
      (defparameter list-with-operators-for-tests-layer-2
        `((subset "subset" subset)
          (not-equal "not-equal" !=)
          (belongs "belongs-to" in)))
      #+end_src
***** code
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (progn
        (bformat t "Testing binary-operators layer 2:")
        (format t "subset:~6t ~a~%"  (subset 1 2))
        (format t "not-equal:~6t ~a~%" (!= 1 2))
        (format t "belongs-to:~6t ~a~%" (in 1 2))
        )
      #+end_src

      #+RESULTS:
      : ===================================
      :  Testing binary-operators layer 2:
      : ===================================
      : 
      : subset:  (subset 1 2)
      : not-equal:  (not-equal 1 2)
      : belongs-to:  (belongs-to 1 2)

** constraint (layer 2)
*** description
    In this section we add the layer 2 for the constraint.  In this section we won't have infix-notation, but it will be a macro where we create var-references for all the variables in the quantifiers.

    In this layer, we have the following sintax:

    #+begin_src lisp
    (constraint id func :quantifiers (q1 q2)
                        :doc "description for the constraint.")
    #+end_src

    The id and the function are mandatory arguments, the quantifiers (if non nil) should be a list where each element is of the form: 

     (for-all-quantifier var-name set-name)

     This form is not evaluated so var-name and set-name should be treated as symbols.  In this second layer we'll create a dummy var-ref with name var-name, so it will shadow any other object with the same name, for the duration of the constraint.
*** code
    #+begin_src lisp :results none :export code :tangle src/ast-nodes.lisp
    (defmacro constraint (id func &key quantifiers doc)
      (let* ((vars-refs-in-quantifiers
              (loop for q in quantifiers
                    when (is-a-for-all-quantifier-list q)
                    collect `(,(second q) (var-ref ',(second q))))))
        `(let* ,vars-refs-in-quantifiers
           (constraint-node ,id ,func
                            :quantifiers (list ,@quantifiers)
                            :doc ,doc))))
    #+end_src
*** tests
**** simple test
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((node1 (constraint 1 (less-than-op 'x 5)))
            (node2 (constraint 2 (less-than-op 'x 5)
                                    :quantifiers
                                    ((for-all-quantifier x 'F))))
            (node3 (constraint 3 (less-than-op 'x 'z)
                                    :quantifiers
                                    ((for-all-quantifier x 'Y nil)
                                     (for-all-quantifier z 'Y nil))))
            ;; (node4 (constraint-node 4 (less-than-op 'x 'z)
            ;;                         :quantifiers
            ;;                         (for-all-quantifier 'x 'Y nil)
            ;;                         :doc "A constraint"))
            ;; (node5 (constraint-node 4 (less-than-op 'x 'z)
            ;;                         :quantifiers
            ;;                         (list
            ;;                          (for-all-quantifier 'x 'Y nil)
            ;;                          (< 'x 3))))
            )
       (bformat t "Testing constraint node (layer 2)")
       (format t "simple constraint: ~A~%" node1)
       (format t "constraint with:   ~A~%" node2)
       (format t "more quantifiers:  ~A~%" node3)
       ;; (format t "documentation:      ~A~%" node4)
       ;; (format t "additional cond:    ~A~%" node5)
       )
     #+end_src
**** test with pred
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((node (for-all-quantifier 'i 'J (greater-than-op 'i 3))))
       (format t "forall with predicate:~% ~a~%" node))
     #+end_src
    

* actual problems
  
** description
   In this section I'll add some actual problems.  I suppose this is the official "tests" section.

** add the package to the file
   #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
   (in-package :lmml)
   #+end_src

** very simple problem (no data, no param) with layer 1
   #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
   (defparameter example1
     (problem-node "example1"
                   (variable-declaration x :var-type binary-variable)
                   (variable-declaration y)

                   (maximize "obj" (add-op (mult-op 4 x)
                                       (mult-op 2 y)))

                   (constraint-node "r1" (less-or-equal-op (add-op x y) 3))))

     #+end_src
** very simple problem (no data, no param) with layer 2 ops
   #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
   (defparameter example2
     (problem-node "example2"
                   (variable-declaration x :var-type binary-variable)
                   (variable-declaration y)

                   (maximize "obj" (+ (* 4 x)
                                      (* 2 y)))

                   (constraint-node "r1" (<= (+ x y) 3))))

     #+end_src
** very simple problem (no data, no param) layer 2 ops and constraint
   #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
   (DEFPARAMETER example2.5
     (PROBLEM-NODE "example2"
                   (variable-declaration x :var-type binary-variable)
                   (variable-declaration y)

                   (maximize "obj" (+ (* 4 x)
                                      (* 2 y)))

                   (constraint "r1" (<= (+ x y) 3))))

     #+end_src
** simple problem with no data but params with layer 2
   #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
   (defparameter example3
     (problem-node "example3"
                   (parameter c1 :value 4)
                   (parameter c2 :value 2)
                   (variable-declaration x :var-type binary-variable
                                         )
                   (variable-declaration y)

                   (maximize "obj" (+ (* c1 x)
                                      (* c2 y)))

                   (constraint-node "r1" (<= (+ x y) 3))))

     #+end_src
** simple problem with params and sets layer 2
   #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
   (defparameter example4
     (problem-node "example4"
                   (set I :value '(1 2))
                   (parameter c1 :value 4)
                   (parameter c2 :value 2)
                   (variable-declaration x :domain (list I)
                                         :var-type binary-variable)

                   (maximize "obj" (+ (* c1 (index-at x 1))
                                      (* c2 (index-at x 2))))

                   (constraint-node "r1" (<= (+ (index-at x 1)
                                                (index-at x 2))
                                             3))))

     #+end_src
** simple problem using range
   #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
   (defparameter example5
     (problem-node "example5"
                   (parameter n :value 5)
                   (set I :value (list (range 1 (+ n 1))))
                   (parameter c1 :value 4)
                   (parameter c2 :value 2)
                   (variable-declaration x :domain (list I)
                                         :var-type binary-variable)

                   (maximize "obj" (+ (* c1 (index-at x 1))
                                      (* c2 (index-at x 2))))

                   (constraint-node "r1" (<= (+ (index-at x 1)
                                                (index-at x 2))
                                             n))

                   (solve)
                   (display x)))

     #+end_src
** simple problem using {}
   #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
   (defparameter example6
     (problem-node "example6"
                   (set I :value {1 2})
                   (parameter c1 :value 4)
                   (parameter c2 :value 2)
                   (variable-declaration x :domain {I I}
                                         :var-type binary-variable)

                   (maximize "obj" (+ (* c1 (index-at x 1 1))
                                      (* c2 (index-at x 2 1))))

                   (constraint-node "r1" (<= (+ (index-at x 1 1)
                                                (index-at x 2 1))
                                             3))))

     #+end_src
** simple problem using {} and []
   #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
   (defparameter example7
     (problem-node "example7"
                   (set I :value {1 2})
                   (parameter c1 :value 4)
                   (parameter c2 :value 2)
                   (variable-declaration x :domain {I I}
                                         :var-type binary-variable)

                   (maximize "obj" (+ (* c1 [x 1 1])
                                      (* c2 [x 2 1])))

                   (constraint-node "r1" (<= (+ [x 1 1]
                                                [x 2 1])
                                             3))))

     #+end_src
** cvrp problem
*** version 2 (second sumf)
    #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
    (defparameter cvrp1
      (problem-node "cvrp1"
          (parameter n :doc "Number of clients")
          (parameter P :doc "Capacity of the vehicles")
          (parameter K :doc "Number of vehicles")
          (parameter M :doc "Sum of the demands")
          (set V :value (list (range 1 n)) :doc "Set of clients")
          (set VD :value (list (range 0 (+ n 1))) :doc "Clients and depots")

          (parameter c :domain (list V V) :doc "Distance betweens clients")
          (parameter d :domain (list V) :doc "Demand of each client")


          (variable-declaration x
                                :var-type binary-variable
                                :domain (list VD VD)
                                :doc "1 if client i is visited right before client j.")

          (variable-declaration y
                                :domain (list VD VD)
                                :doc "A variable to track the commodity flow")

          (minimize "obj" (sumf ((i in VD))
                                (sumf ((j in VD))
                                      (* (index-at x i j)
                                         (index-at c i j)))))

          (constraint "r1"
                      (= (sumf ((j in VD))
                               (- [y j i] [y i j]))
                         (* 2 [d i]))
                      :quantifiers ((for-all-quantifier i V))
                      :doc "Flow preserving condition")

          (constraint "r2" (= (sumf ((j in V)) [y 0 j])
                              M)
                      :doc "All the demand leaves the depot")

          (constraint "r3" (= (sumf ((j in V)) [y j 0])
                              (- (* K P) M))
                      :doc "The depot receives the remaining demand")

          (constraint "r4" (= (sumf ((j in V)) [y (+ n 1) j])
                              (* K P))
                      :doc "Correct Yij values leaving the depot")

          (constraint "r5" (= (+ [y i j] [y j i])
                              (* P [x i j]))
                      :quantifiers ((for-all-quantifier i VD)
                                    (for-all-quantifier j VD))
                      :doc "Relationship between Yij values at each node")

          (constraint "r6" (= (sumf ((j in V))  (+ [x i j]
                                                   [x j i]))
                              2)
                      :quantifiers ((for-all-quantifier i V))
                      :doc "Each client is visited and departed exactly once.")

          ))



       ;; (problem "cvrp"
       ;;              (set V)
       ;;              (set I)
       ;;              (param c :domain {V V})
       ;;              (param d :domain {V})
       ;;              (param n)
       ;;              (param P)
       ;;              (param K)
       ;;              (param M)
       ;;              (binary-variable x :domain {V V})
       ;;              (variable        y :domain {V V})
       ;;              (minimize (sum (a in V)
       ;;                          (sum (b in V)
       ;;                              x[a b] * c[a b])))
       ;;              (s.t. (sum (b in V)
       ;;                        y[b a] - y[a b]) = 2 * d[a]
       ;;                    (forall a in I))
       ;;              (s.t. (sum (b in I) y[0 b]) = M)
       ;;              (s.t. (sum (b in I) y[b 0]) = K * P - M)
       ;;              (s.t. (sum (b in I) y[n + 1 b]) = K * P)
       ;;              (s.t. y[a b] + y[b a] = P * x[a b]
       ;;                    (forall a in V)
       ;;                    (forall b in V))
       ;;              (s.t. (sum (b in V)  x[a b] + x[b a]) = 2
       ;;                    (forall a in I)))
      #+end_src
*** +version 1 (first sumf)+
    #+begin_src lisp :results none :export code
    (defparameter cvrp1
      (problem-node "cvrp1"
          (parameter n :doc "Number of clients")
          (parameter P :doc "Capacity of the vehicles")
          (parameter K :doc "Number of vehicles")
          (parameter M :doc "Sum of the demands")
          (set V :value (list (range 1 n)) :doc "Set of clients")
          (set VD :value (list (range 0 (+ n 1))) :doc "Clients and depots")

          (parameter c :domain (list V V) :doc "Distance betweens clients")
          (parameter d :domain (list V) :doc "Demand of each client")


          (variable-declaration x
                                :var-type binary-variable
                                :domain (list VD VD)
                                :doc "1 if client i is visited right before client j.")

          (variable-declaration y
                                :domain (list VD VD)
                                :doc "A variable to track the commodity flow")

          (minimize "obj" (sumf (i :in VD)
                                (sumf (j :in VD)
                                      (* (index-at x i j)
                                         (index-at c i j)))))

          (constraint "r1"
                      (= (sumf (j :in VD)
                               (- [y j i] [y i j]))
                         (* 2 [d i]))
                      :quantifiers ((for-all-quantifier i V))
                      :doc "Flow preserving condition")

          (constraint "r2" (= (sumf (j :in V) [y 0 j])
                              M)
                      :doc "All the demand leaves the depot")

          (constraint "r3" (= (sumf (j :in V) [y j 0])
                              (- (* K P) M))
                      :doc "The depot receives the remaining demand")

          (constraint "r4" (= (sumf (j :in V) [y (+ n 1) j])
                              (* K P))
                      :doc "Correct Yij values leaving the depot")

          (constraint "r5" (= (+ [y i j] [y j i])
                              (* P [x i j]))
                      :quantifiers ((for-all-quantifier i VD)
                                    (for-all-quantifier j VD))
                      :doc "Relationship between Yij values at each node")

          (constraint "r6" (= (sumf (j :in V)  (+ [x i j]
                                                  [x j i]))
                              2)
                      :quantifiers ((for-all-quantifier i V))
                      :doc "Each client is visited and departed exactly once.")

          ))



       ;; (problem "cvrp"
       ;;              (set V)
       ;;              (set I)
       ;;              (param c :domain {V V})
       ;;              (param d :domain {V})
       ;;              (param n)
       ;;              (param P)
       ;;              (param K)
       ;;              (param M)
       ;;              (binary-variable x :domain {V V})
       ;;              (variable        y :domain {V V})
       ;;              (minimize (sum (a in V)
       ;;                          (sum (b in V)
       ;;                              x[a b] * c[a b])))
       ;;              (s.t. (sum (b in V)
       ;;                        y[b a] - y[a b]) = 2 * d[a]
       ;;                    (forall a in I))
       ;;              (s.t. (sum (b in I) y[0 b]) = M)
       ;;              (s.t. (sum (b in I) y[b 0]) = K * P - M)
       ;;              (s.t. (sum (b in I) y[n + 1 b]) = K * P)
       ;;              (s.t. y[a b] + y[b a] = P * x[a b]
       ;;                    (forall a in V)
       ;;                    (forall b in V))
       ;;              (s.t. (sum (b in V)  x[a b] + x[b a]) = 2
       ;;                    (forall a in I)))
      #+end_src
** example in gmpl documentation
*** version 2 (second sumf)
    #+begin_src lisp :results none :export code :tangle src/problem-examples.lisp
    (defparameter gmpl-example1
      (problem-node "A transportation problem"

          (set I :doc "Canning plants")

          (set J :doc "Markets")


          (parameter a :domain {I} :doc "Capacity of plant i in cases")

          (parameter b :domain {J} :doc "Demand at market j in cases")


          (parameter d :domain {I J} :doc "Distance in thousands of miles")

          (parameter f :doc "Freight in dollars per case per thousand miles")

          (parameter c :domain {I J}
                     :doc "Transport cost in thousands of dollars per case")

          (variable-declaration x
                                :domain {I J}
                                :doc "Shipment quantities in cases")



          (minimize "cost" (sumf ((k in I))
                                (sumf ((l in J))
                                      (* [c k l]
                                         [x k l])))
                    :doc "Total transportation costs in thousands of dollars.")

          (constraint "supply"
                      (<= (sumf ((l in J))
                                [x k l])
                          [a k])
                      :quantifiers ((for-all-quantifier k I))
                      :doc "Observe supply limit at plant i")

          (constraint "demand"
                      (>= (sumf ((k in I))
                                [x k l])
                          [b l])
                      :quantifiers ((for-all-quantifier l J))
                      :doc "Satisfy demand at market J")


          (data-section
           (set-value-of-set I (list "Seattle" "San-Diego"))

           (set-value-of-set J (list "New-York" "Chicago" "Topeka"))

           (set-value-of-param a '(350 600))

           (set-value-of-param b '(325 300 275))

           (set-value-of-param d '((2.5 1.7 1.8)
                                   (2.5 1.8 1.4)))

           (set-value-of-param f 90)

           ;; c[i,j] = f * d[i, j] / 1000
           ;; c[i,j] = d[i, j] * 0.09
           (set-value-of-param c (list (list (cl:* 0.09 2.5)
                                        (cl:* 0.09 1.7)
                                        (cl:* 0.09 1.8))
                                       (list (cl:* 0.09 2.5)
                                        (cl:* 0.09 1.8)
                                        (cl:* 0.09 1.4)))))))
      #+end_src
*** +version 1 (first sumf)+
    #+begin_src lisp :results none :export code
    (defparameter gmpl-example1
      (problem-node "A transportation problem"

          (set I :doc "Canning plants")

          (set J :doc "Markets")


          (parameter a :domain {I} :doc "Capacity of plant i in cases")

          (parameter b :domain {J} :doc "Demand at market j in cases")


          (parameter d :domain {I J} :doc "Distance in thousands of miles")

          (parameter f :doc "Freight in dollars per case per thousand miles")

          (parameter c :domain {I J}
                     :doc "Transport cost in thousands of dollars per case")

          (variable-declaration x
                                :domain {I J}
                                :doc "Shipment quantities in cases")



          (minimize "cost" (sumf (k :in I)
                                (sumf (l :in J)
                                      (* [c k l]
                                         [x k l])))
                    :doc "Total transportation costs in thousands of dollars.")

          (constraint "supply"
                      (<= (sumf (l :in J)
                                [x k l])
                          [a k])
                      :quantifiers ((for-all-quantifier k I))
                      :doc "Observe supply limit at plant i")

          (constraint "demand"
                      (>= (sumf (k :in I)
                                [x k l])
                          [b l])
                      :quantifiers ((for-all-quantifier l J))
                      :doc "Satisfy demand at market J")


          (data-section
           (set-value-of-set I (list "Seattle" "San-Diego"))

           (set-value-of-set J (list "New-York" "Chicago" "Topeka"))

           (set-value-of-param a '(350 600))

           (set-value-of-param b '(325 300 275))

           (set-value-of-param d '((2.5 1.7 1.8)
                                   (2.5 1.8 1.4)))

           (set-value-of-param f 90)

           ;; c[i,j] = f * d[i, j] / 1000
           ;; c[i,j] = d[i, j] * 0.09
           (set-value-of-param c (list (list (cl:* 0.09 2.5)
                                        (cl:* 0.09 1.7)
                                        (cl:* 0.09 1.8))
                                       (list (cl:* 0.09 2.5)
                                        (cl:* 0.09 1.8)
                                        (cl:* 0.09 1.4)))))))
      #+end_src
   

* TODO code generation

** description
   In this section we add the code for the code-generation in several languages. 

   I'll also create a file code-generation-utils.lisp, where I'll store some utilities for the code-generation.


** file code-generation-utils
   #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
   (in-package :lmml)
   #+END_SRC


** utility functions for the code generation

*** generic-function write-name
**** description
     The write-name generic function is a function that will be used to write the name of sets, parameters and variables.  Having this function will allow for conventions in the name of the variables and sets.
**** code (generic-function)
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/generic-functions.lisp
      (defgeneric write-name (obj lang stream)
        (:documentation "Defines how to write the name of the given object in the given language to the specified stream."))
      #+END_SRC
    

*** generic-function format-value-of
**** description
     This generic function will format the value of a set or parameter according to the data-reader and the language used.  It has 4 parameters
     - the node that should be formatted,
     - the value that should be formatted,
     - the language,
     - the data-reader, and
     - the stream.
**** code (generic-function)
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/generic-functions.lisp
      (defgeneric format-value-of (obj value lang data-reader stream)
        (:documentation "Defines how to format the value of the given object in the given language using the specified data-reader."))
      #+END_SRC
*** generic-function value
**** description
     This function returns the value of a parameter or a set.  It is already defined as a slot, so in this section, I'll write methods for other classes that don't have the slot, such as param-refs, numbers, and (in some future) the arithmetic operators.
**** method for number
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod value ((obj number))
        "If it is a number, just return it."
        obj)
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ()
       (bformat t "Testing value for number")
       (format t "Value of number: ~a~%" (value 18)))
     #+end_src
**** method for param-ref
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod value ((obj param-ref))
        "If it is a param-ref, just return the value in the original declaration."
        (value (original-declaration obj)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl (parameter-declaration-node
                         "p1" :value 16))
            (p1 (param-ref "p1" param-decl)))

       (bformat t "Testing value for param-ref")
       (format t "Value of param-ref: ~a~%" (value p1)))
     #+end_src
**** method for set-ref
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod value ((obj set-ref))
        "If it is a set-ref, just return the value in the original declaration."
        (value (original-declaration obj)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl (parameter-declaration-node
                         "p1" :value 16))
            (p1 (param-ref "p1" param-decl)))

       (bformat t "Testing value for param-ref")
       (format t "Value of param-ref: ~a~%" (value p1)))
     #+end_src
**** method for the binary-operators
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (generate-value-for-binary-operators
        ((add  cl:+)
         (subs cl:-)
         (mult cl:*)
         (div  cl:/)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl (parameter-declaration-node
                         "p1" :value 16))
            (p1 (param-ref "p1" param-decl))
            (node1 (add-op 1 3))
            (node2 (subs-op 1 3))
            (node3 (mult-op 1 3))
            (node4 (div-op 1 3))
            (node5 (add-op p1 3))
            (node6 (mult-op 3 p1))
            (node7 (subs-op p1 p1))

            )

       (bformat t "Testing value for binary-ops with 1 op 3")
       (format t "Value of +: ~2d~%" (value node1))
       (format t "Value of -: ~2d~%" (value node2))
       (format t "Value of *: ~2d~%" (value node3))
       (format t "Value of /: ~2d~%" (value node4))

       (bformat t "Testing value for binary-ops with p1 with value ~a"
                (value p1))
       (format t "Value of p1 +  3: ~2d~%" (value node5))
       (format t "Value of  3 * p1: ~2d~%" (value node6))
       (format t "Value of p1 - p1: ~2d~%" (value node7))
       )
     #+end_src


*** generic-function current-value
**** description
     This function returns the current-value of a parameter or a set.  It is already defined as a slot, so in this section, I'll write methods for other classes that don't have the slot, such as param-refs, numbers, and (in some future) the arithmetic operators.
**** method for number
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod current-value ((obj number))
        "If it is a number, just return it."
        obj)
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ()
       (bformat t "Testing value for number")
       (format t "current-value of number: ~a~%" (current-value 18)))
     #+end_src
**** method for param-ref
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod current-value ((obj param-ref))
        "If it is a param-ref, just return the current-value in the original declaration."
        (current-value (original-declaration obj)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl (parameter-declaration-node
                         "p1" :value 16))
            (p1 (param-ref "p1" param-decl))
            (param-decl2 (parameter-declaration-node
                          "p2" :value 16
                          :current-value 14))
            (p2 (param-ref "p2" param-decl2)))

       (bformat t "Testing current-value for param-ref")
       (format t "current-value of param-ref: ~a~%" (current-value p1))
       (format t "current-value of param-ref: ~a~%" (current-value p2)))
     #+end_src
**** method for set-ref
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod current-value ((obj set-ref))
        "If it is a set-ref, just return the current-value in the original declaration."
        (current-value (original-declaration obj)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl (parameter-declaration-node
                         "p1" :value 16))
            (p1 (param-ref "p1" param-decl))
            (param-decl2 (parameter-declaration-node
                               "p2" :value 16
                               :current-value 14))
            (p2 (param-ref "p2" param-decl2)))

       (bformat t "Testing current-value for param-ref")
       (format t "Value of param-ref: ~a~%" (current-value p1))
       (format t "Value of param-ref: ~a~%" (current-value p2)))
     #+end_src
**** method for the binary-operators
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (generate-current-value-for-binary-operators
        ((add  cl:+)
         (subs cl:-)
         (mult cl:*)
         (div  cl:/)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl (parameter-declaration-node
                         "p1" :value 16
                         :current-value 16))
            (p1 (param-ref "p1" param-decl))
            (node1 (add-op 1 3))
            (node2 (subs-op 1 3))
            (node3 (mult-op 1 3))
            (node4 (div-op 1 3))
            (node5 (add-op p1 3))
            (node6 (mult-op 3 p1))
            (node7 (subs-op p1 p1))

            )

       (bformat t "Testing current-value for binary-ops with 1 op 3")
       (format t "Value of +: ~2d~%" (current-value node1))
       (format t "Value of -: ~2d~%" (current-value node2))
       (format t "Value of *: ~2d~%" (current-value node3))
       (format t "Value of /: ~2d~%" (current-value node4))

       (bformat t "Testing value for binary-ops with p1 with value ~a"
                (current-value p1))
       (format t "Value of p1 +  3: ~2d~%" (current-value node5))
       (format t "Value of  3 * p1: ~2d~%" (current-value node6))
       (format t "Value of p1 - p1: ~2d~%" (current-value node7))
       )
     #+end_src


*** generic-function domain
**** description
     This function returns the domain of a parameter or a variable.  It is already defined as a slot, so in this section, I'll write methods for other classes that don't have the slot, such as param-refs and var-refs
**** method for param-ref
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod domain ((obj param-ref))
        "If it is a param-ref, return the domain in the original declaration."
        (domain (original-declaration obj)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl (parameter-declaration-node
                         "p1" :value 16))
            (p1 (param-ref "p1" param-decl))
            (s-decl (set-declaration-node "S" :value '(a b c)))
            (s (set-ref "S" s-decl))
            (param-decl2 (parameter-declaration-node
                          "p2" :value {1 2 3} :domain s))
            (p2 (param-ref "p2" param-decl2)))

       (bformat t "Testing value for param-ref")
       (format t "domain of param-ref: ~a~%" (domain p1))
       (format t "domain of param-ref: ~a~%" (domain p2))
       (format t "value of domain of param-ref: ~a~%" (value (domain p2))))
     #+end_src
**** method for var-ref
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod domain ((obj var-ref))
        "If it is a set-ref, return the domain in the original declaration."
        (domain (original-declaration obj)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((v1-decl (variable-declaration-node
                      "v1"))
            (v1 (var-ref "v1" v1-decl))
            (s-decl (set-declaration-node "S" :value '(a b c)))
            (s (set-ref "S" s-decl))
            (v2-decl (variable-declaration-node
                      "v2" :domain s))
            (v2 (var-ref "v2" v2-decl))
            )

       (bformat t "Testing domain for param-ref")
       (format t "domain of param-ref: ~a~%" (domain v1))
       (format t "domain of param-ref: ~a~%" (domain v2))
       (format t "value of domain of param-ref: ~a~%" (value (domain v2)))
       )
     #+end_src


*** generic-function name
**** description
     This function returns the name of an element.  It is already defined as a slot in some classes, so in this section, I'll write methods for other classes (or data types) that don't have the slot, such as numbers and other possible elements in a set.
**** method for number
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod name ((obj number))
        "If it is a number, return a string with it."
        (mkstr obj))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ()
       (bformat t "Testing name for number")
       (format t "Value of number: ~a~%" (name 18))
       (format t "Value of number: ~a~%" (name 111330))
       (format t "Value of number: ~a~%" (name -111330)))
     #+end_src
**** method for symbol
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod name ((obj symbol))
        "If it is a symbol, return a string with it."
        (mkstr obj))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ()
       (bformat t "Testing name for number")
       (format t "Value of number: ~a~%" (name 'hello))
       (format t "Value of number: ~a~%" (name 'hello-world))
       (format t "Value of number: ~a~%" (name 'hello-111330)))
     #+end_src
**** method for string
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod name ((obj string))
        "If it is a string, just return it."
        obj)
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ()
       (bformat t "Testing name for number")
       (format t "Value of number: ~a~%" "hello")
       (format t "Value of number: ~a~%" "hello-world")
       (format t "Value of number: ~a~%" "hello-111330"))
     #+end_src
**** method for set-ref
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod name ((obj set-value-of-set))
        "If it is a set-value-of-set, return the name of the set-name."
        (name (set-name obj)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((set-decl-1 (set-declaration-node "S"))
             (p (set-ref "S" set-decl-1))
             (node1 (set-value-of-set p 5))
             (node2 (set-value-of-set p 5 8))
             (node3 nil)
             (node4 nil)
             )
        (bformat t "Testing name for set-value-of-set")
        (format t "Expect S: ~a~%" (name p))
        (format t "~a~%" node1)
        (format t "Expect S: ~a~%" (name node1))
        (format t "Expect S: ~a~%" (name node2))

        (setf node3 (set-value-of-set p '(1 2 3 4)))
        (format t "~a~%" node3)
        (format t "Expect S: ~a~%" (name node3))
        (setf node4 (set-value-of-set p (range 1 5)))
        (format t "~a~%" node4)
        (format t "Expect S: ~a~%" (name node4)))
     #+end_src
**** method for param-ref
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod name ((obj set-value-of-param))
        "If it is a set-value-of-param, return the name of the param-name."
        (name (param-name obj)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl-1 (parameter-declaration-node "P"))
             (p (param-ref "P" param-decl-1))
             (node1 (set-value-of-param p 5))
             (node2 (set-value-of-param p 5 8)))
        (bformat t "Testing name of set-value-of-param")
        (format t "Expect P: ~a~%" (name p))
   
        (format t "Expect P: ~a~%" (name node1))
   
        (setf node3 (set-value-of-param p '(1 2 3 4)))
        (format t "Expect P: ~a~%" (name node2)))
     #+end_src


*** generic-function generate-value-of-set
**** description
     This function should receive a set-value specification and return and appropriate lisp element representing the same set.  This is required for the code-generation of the nodes set-value-of-param in GMPL.

     For instance: if this function receives a list, it returns the same list.  If it receives a range-node specification, it returns a list with the values specified by the range-node.

     For example:

     (generate-value-of-set (range 1 5) +standard-data-reader+)

     should return the list

     `(1 2 3 4 5)

     It receives the set specification and a data-reader.
**** code (generic-function)
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/generic-functions.lisp
      (defgeneric generate-value-of-set (obj data-reader)
        (:documentation "Returns a lisp object with the elements specified in the obj."))
      #+END_SRC
**** method for list
***** description
      If this method receives a list, it returns the same list.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod generate-value-of-set ((node list)
                                        (data-reader standard-data-reader))
        "If it is a list, just return it."
        node)

      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((node1 '(1 2 3 4 5))
            (node2 (list 1 2 3 4 5 6 7 8))
            (dreader +standard-data-reader+))

       (bformat t "Testing generate-value-of-set with list")
       (format t "~a~%" (generate-value-of-set node1 dreader)) (terpri)
       (format t "~a~%" (generate-value-of-set node2 dreader)) (terpri)
       )
     #+end_src
**** method for range-node
***** description
      If this method receives a range-node, it returns a list with the elements specified in the range-node.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod generate-value-of-set ((node range-node)
                                        (data-reader standard-data-reader))
        "If it is a range-node, generate a list with the elements in that range."
        (let* ((min (value (min-value node)))
               (max (value (max-value node)))
               (inc (value (increment node))))
          (if (cl:> inc 0)
              (loop for i from min to max by inc
                    collecting i)
              (loop for i from min downto max by (cl:- inc)
                     collecting i))))

      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((param-decl (parameter-declaration-node "p1" :value 5))
            (p1 (param-ref "p1" param-decl))
            (node1 (range 1 5))
            (node2 (range 1 10 :increment 2))
            (node3 (range 5  1 :increment -1))
            (node4 (range 1 (+ 5 5)))
            (node5 (range (- 3 1) (+ 5 5)))
            (node6 (range p1 (+ 5 5)))
            (node7 (range 1 p1))
            (node8 (range 1 (* p1 2)))
            (dreader +standard-data-reader+))

       (bformat t "Testing generate-value-of-set with range-node")
       (format t "~a~%" (generate-value-of-set node1 dreader))
       (format t "~a~%" (generate-value-of-set node2 dreader))
       (format t "~a~%" (generate-value-of-set node3 dreader))
       (format t "~a~%" (generate-value-of-set node4 dreader))
       (format t "~a~%" (generate-value-of-set node5 dreader))
       (format t "~a~%" (generate-value-of-set node6 dreader))
       (format t "~a~%" (generate-value-of-set node7 dreader))
       (format t "~a~%" (generate-value-of-set node8 dreader))
       )
     #+end_src


*** generic-function make-dummy-variable-name-generator
**** description

     This function is used to generate the name of dummy variables, for instance in the parameter and variable declarations in GMPL.

     The idea is te return a closure that every time it is called, returns a new name.

     First it will return the lowercase letters: i, j, k, and l, and then it will start appending numbers to each of them.

     I'll make it a generic function, just in case we need te change some behaviour in the future.

     The generic function receives the language where we'll use the generated variable name
**** generic-function
     #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/generic-functions.lisp
     (defgeneric make-dummy-variable-name-generator (language)
        (:documentation "Returns a closure that every time it is called returns a new name for a dummy variable."))
     #+END_SRC
**** method for any-language
***** description
      In this method, we iterate through the names i, j, k and l, and if they are exhausted, we append numbers to them i2, j2, k2, l2, i3, j3, and so on.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/code-generation-utils.lisp
      (defmethod make-dummy-variable-name-generator ((lang t))
        "If it is a list, just return it."
        (let* ((names-list '("i" "j" "k" "l"))
               (current-number 1)
               (current-index 0))
          (lambda ()
            (prog1
                (concatenate
                 'string
                 (string-downcase (nth current-index names-list))
                 (if (cl:> current-number 1)
                     (mkstr current-number)
                     ""))
              (incf current-index)
              (when (cl:>= current-index (length names-list))
               (setf current-index 0)
               (incf current-number))))))

      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((name-generator (make-dummy-variable-name-generator t)))

       (bformat t "Testing make-dummy-variable-name-generator")
       (dotimes (i 12)
        (format t "~a~%" (funcall name-generator))))
     #+end_src
   

** basic languages

*** basic language

**** description
     In this section I'll create the basic languages and its corresponding code-generations.  The src-blocks will be tangled to basic-languages.lisp.

     A basic language will have a slot with the symbol used for each binary-operation.
**** add the package to the file
     #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
     (in-package :lmml)
     #+END_SRC

**** macro for the creation of the basic-language
***** description
      In this section we create a macro that will write for us the code for the creation of the basic-class.

      For example, the following code:
      #+begin_src lisp :exports code :results none
      (define-basic-language ((plus \"+\" \"addition\")
                              (minus \"-\" \"substraction\")))
      #+end_src
      should expand into:
      #+begin_src lisp :exports code :results none
      (defclass basic-language ()
        ((plus-symbol :accessor plus-symbol :initarg :plus-symbol
                       :initform \"+\"
                       :documentation \"The symbol used for the addition.\")
         (minus-symbol :accessor minus-symbol :initarg :minus-symbol
                        :initform \"-\"
                        :documentation \"The symbol used for the addition.\"))
        (:documentation \"The basic class for languages with arithmetic operators.\"))
      #+end_src

***** help function make-slots-for-basic-language
****** description
       This function receives a list with the data for a basic-language slot.  This list contains the name of the slot (without the =-op= suffix) and the text that should be used in this language.

       For example, the following code:
       #+begin_src lisp :exports code :results none
       (defun make-slots-for-basic-language '(add \"+\" \"addition\"))
       #+end_src
       returns
       #+begin_src lisp :exports code :results none
       `(add-symbol :accessor add-symbol
                     :initarg :add-symbol
                     :initform "+"
                     :documentation "The symbol used for the addition.")
       #+end_src
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defun make-slots-for-basic-language (slot-list)
         (loop for (prefix symbol name) in slot-list
               for node-name = (symb prefix "-symbol")
               for initarg = (make-keyword node-name)
               for docstring = (format nil "The symbol used for the ~a." name)
               collecting `(,node-name
                             :accessor ,node-name :initarg ,initarg
                             :initform ,symbol
                             :documentation ,docstring)))
       #+END_SRC
****** tests
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (format t "~s~%" (make-slots-for-basic-language
                         `((add "+" "addition")
                           (subs "-" "substraction")
                           (weird nil "weird op"))))
       #+end_src
***** code for the macro
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmacro define-basic-language (language-name
                                        super-classes
                                        operators-list)
         "Creates the class named language-name, with parents super-classes and adds all the operators in the list.
        Syntax:
          (define-basic-language language-name super-classes operators-list)
         operators-list is a list where each element is of the form:
            (node-prefix symbol-used operation-name).
          Example:
            (define-basic-language basic-language () 
                                    ((plus \"+\" \"addition\")
                                     (minus \"-\" \"substraction\")))
           expands into
             (defclass basic-language ()
               ((plus-symbol :accessor plus-symbol :initarg :plus-symbol
                             :initform \"+\"
                             :documentation \"The symbol used for the addition.\")
                (minus-symbol :accessor minus-symbol :initarg :minus-symbol
                              :initform \"-\"
                              :documentation \"The symbol used for the addition.\"))
               (:documentation \"The basic class for languages with arithmetic operators.\"))"
         `(defclass ,language-name ,super-classes
            ,(make-slots-for-basic-language (if (symbolp operators-list)
                                                (symbol-value operators-list)
                                                operators-list))
            (:documentation "The basic class for languages with arithmetic operators.")))
       #+END_SRC
****** testing macroexpansion
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (define-basic-language test-language ()
         ((add "+" "addition")
          (subs "-" "substraction")
          (weird nil "weird op"))) 
       #+end_src
     
       #+begin_src lisp :exports code :results none
       (DEFCLASS TEST-LANGUAGE NIL
            ((ADD-SYMBOL :ACCESSOR ADD-SYMBOL :INITARG :ADD-SYMBOL :INITFORM "+"
                         :DOCUMENTATION "The symbol used for the addition.")
             (SUBS-SYMBOL :ACCESSOR SUBS-SYMBOL :INITARG :SUBS-SYMBOL :INITFORM
                          "-" :DOCUMENTATION
                          "The symbol used for the substraction.")
             (WEIRD-SYMBOL :ACCESSOR WEIRD-SYMBOL :INITARG :WEIRD-SYMBOL
              :INITFORM NIL :DOCUMENTATION "The symbol used for the weird op."))
            (:DOCUMENTATION
             "The basic class for languages with arithmetic operators."))
       #+end_src
**** class basic-language
***** description
      This is a basic language with only the slots with the name of the operations.  We create it with the macro
***** list with the slots operations for the basic language
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defparameter *basic-language-binary-operators*
         '((add                "+" "addition")
           (subs               "-" "substraction")
           (mult               "*" "multiplication")
           (div                "/" "division")
           (less-than          "<" "less than comparison")
           (less-or-equal      "<=" "less than or equal to")
           (greater-than       ">" "greater than comparison")
           (greater-or-equal   ">=" "greater than or equal to")
           (equality           "=" "equality comparison")
           (assignment         nil "assignment operation")
           (union              nil "union of sets")
           (intersection       nil "intersection of sets")
           (difference         nil "set difference")
           (cartesian-product  nil "cartesian product X times Y"))
         "A list with the operators used by the basic language.")
       #+END_SRC
***** code for the basic-language
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (define-basic-language basic-language nil 
         ,*basic-language-binary-operators*)
       #+END_SRC
***** tests
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'basic-language)))
         (bformat t "Testing basic-language operators:")
         (format t "+:   ~a~%" (add-symbol lang))
         (format t "-:   ~a~%" (subs-symbol lang))
         (format t "*:   ~a~%" (mult-symbol lang))
         (format t "/:   ~a~%" (div-symbol lang))
         (format t "<:   ~a~%" (less-than-symbol lang))
         (format t "<=:  ~a~%" (less-or-equal-symbol lang))
         (format t ">:   ~a~%" (greater-than-symbol lang))
         (format t ">=   ~a~%" (greater-or-equal-symbol lang))
         (format t "=    ~a~%" (equality-symbol lang))
         (format t "nil: ~a~%" (assignment-symbol lang))
         (format t "nil: ~a~%" (union-op-symbol lang))
         (format t "nil: ~a~%" (intersection-symbol lang))
         (format t "nil: ~a~%" (difference-symbol lang))
         (format t "nil: ~a~%" (cartesian-product-symbol lang)))
       #+end_src
**** code generation for the basic elements in the basic language
***** number
****** description
       A the generated code for a number is the number itself.
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code ((node number)
                                 (lang basic-language)
                                 stream)
         (format stream "~a" node))
       #+END_SRC
****** test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'basic-language)))
         (bformat t "Testing code-generation for numbers:")
         (generate-code 4 lang t))
       #+end_src
***** string
****** description
       A the generated code for a string is the string itself.
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code ((node string)
                                 (lang basic-language)
                                 stream)
         (format stream "~a" node))
       #+END_SRC
      
****** test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'basic-language)))
         (bformat t "Testing code-generation for strings:")
         (generate-code "hello" lang t))
       #+end_src
***** list
****** description
       A the generated code for a list is the elements side by side.
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code((node list)
                                (lang basic-language)
                                (stream t))
         (format stream "~{~a~^ ~}"
                 (mapcar (lambda (x) (gcodenil-exp x))
                         node)))
       #+END_SRC
****** test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'basic-language)))
         (bformat t "Testing code-generation for lists:")
         (generate-code `(1 2 "three") lang t))
       #+end_src
***** instructions-list
****** description
       A the generated code for a instructions-list is the elements separated by a newline.
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code((node instructions-list)
                                (lang t)
                                (stream t))
         (format stream "~{~a~^~2%~}"
                 (mapcar (lambda (x) (gcodenil-exp x))
                         (elements node))))
       #+END_SRC
****** test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'basic-language)))
         (bformat t "Testing code-generation for instructions-lists:")
         (generate-code (instructions-list 1 2 "three") lang t))
       #+end_src


*** infix-language
**** description
     In this section I'll create the infix-language code generation.  The src-blocks will be tangled to basic-languages.lisp.

     The infix-language will only specialize the code generation for the operators in an infix way.

     In the first layer, all the operations will have parenthesis around them.  In next steps I'll remove the useless parenthesis.

     To create the code-generation methods we'll use a macro that receives a string with the position of the operator and the operands, and a list with the name of the slots that should be processed.

**** class infix-language
***** description
      The class to represent the infix-language
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
      (defnode infix-language (basic-language)
        ())
      #+END_SRC
**** code generation for the infix language
***** description
      To generate the code we'll use the macro =generate-code-for-binary-operators=.
***** list with the slots operations for the basic language
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
             (defparameter *basic-language-binary-operators-except-mult-div-subs*
               '((add                "+" "addition")
                 (less-than          "<" "less than comparison")
                 (less-or-equal      "<=" "less than or equal to")
                 (greater-than       ">" "greater than comparison")
                 (greater-or-equal   ">=" "greater than or equal to")
                 (equality           "=" "equality comparison")
                 (assignment         nil "assignment operation")
                 (union              nil "union of sets")
                 (intersection       nil "intersection of sets")
                 (difference         nil "set difference")
                 (cartesian-product  nil "cartesian product X times Y"))
               "A list with the operators used by the basic language.")
       #+END_SRC

***** code for all but mult and div and subs
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (generate-code-for-binary-operators
        infix-language
        "~a ~a ~a"
        (left op right)
        ,*basic-language-binary-operators-except-mult-div-subs*)
       #+END_SRC
****** test
******* basic tests
        #+begin_src lisp :results output :export code :tangle src/tests.lisp
        (let* ((lang (make-instance 'infix-language)))
          (bformat t "Testing code-generation for infix-language")
          (generate-code (+  1 2) lang t) (terpri) 
          (generate-code (<  1 2) lang t) (terpri)
          (generate-code (<= 1 2) lang t) (terpri)
          (generate-code (>  1 2) lang t) (terpri)
          (generate-code (>= 1 2) lang t) (terpri)
          (generate-code (=  1 2) lang t) (terpri)
          (bformat t "Testing the addition of the extra parenthesis")
          (generate-code (+  (+ 1 1) (- 3 2)) lang t) (terpri) 
          (generate-code (<  (- 1 3) (+ 2 4)) lang t) (terpri)
          (generate-code (<= (- 1 3) (+ 2 4)) lang t) (terpri)
          (generate-code (>  (- 1 3) (+ 2 4)) lang t) (terpri)
          (generate-code (>= (- 1 3) (+ 2 4)) lang t) (terpri)
          (generate-code (=  (- 1 3) (+ 2 4)) lang t) (terpri)
          )
        #+end_src

	#+RESULTS:
	#+begin_example
	============================================
	 Testing code-generation for infix-language
	============================================

	1 + 2
	1 < 2
	1 <= 2
	1 > 2
	1 >= 2
	1 = 2
	===============================================
	 Testing the addition of the extra parenthesis
	===============================================

	1 + 1 + 3 - 2
	1 - 3 < 2 + 4
	1 - 3 <= 2 + 4
	1 - 3 > 2 + 4
	1 - 3 >= 2 + 4
	1 - 3 = 2 + 4
	#+end_example

***** code-generation for mult-node
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code ((node mult-op)
                                 (lang infix-language)
                                 stream)
         (let* ((format-string (concatenate 'string
                                            (if (or
                                                 (subtypep (type-of (left node)) 'add-op)
                                                 (subtypep (type-of (left node)) 'subs-op))
                                                "(~a)"
                                                "~a")
                                            "~a"
                                            (if (or
                                                 (subtypep (type-of (right node)) 'add-op)
                                                 (subtypep (type-of (right node)) 'subs-op))
                                                "(~a)"
                                                "~a"))))
           (format stream format-string
                   (gcodenil left)
                   (gcodenil-exp (mult-symbol lang))
                   (gcodenil right))))
       #+END_SRC
****** test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'infix-language)))
         (bformat t "Testing code-generation for infix-language")
         (generate-code (*  1 2) lang t) (terpri) 
         (generate-code (*  (+ 1 3) 2) lang t) (terpri)
         (generate-code (*  1 (+ 2 3)) lang t) (terpri)
         (generate-code (* (+ 1 3) (+ 2 4)) lang t) (terpri))
       #+end_src
***** code-generation for div-node
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code ((node div-op)
                                 (lang infix-language)
                                 stream)
         (let* ((format-string (concatenate 'string
                                            (if (or
                                                 (subtypep (type-of (left node)) 'add-op)
                                                 (subtypep (type-of (left node)) 'subs-op))
                                                "(~a)"
                                                "~a")
                                            "~a"
                                            (if (or
                                                 (subtypep (type-of (right node)) 'add-op)
                                                 (subtypep (type-of (right node)) 'subs-op))
                                                "(~a)"
                                                "~a"))))
           (format stream format-string
                   (gcodenil left)
                   (gcodenil-exp (div-symbol lang))
                   (gcodenil right))))
       #+END_SRC
****** test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'infix-language)))
         (bformat t "Testing code-generation for div node in infix-language")
         (generate-code (/  1 2) lang t) (terpri) 
         (generate-code (/  (+ 1 3) 2) lang t) (terpri)
         (generate-code (/  1 (+ 2 3)) lang t) (terpri)
         (generate-code (/ (+ 1 3) (+ 2 4)) lang t) (terpri)
         (generate-code (/ (* 1 3) 2) lang t) (terpri)
         (generate-code (/ 1 (* 2 4)) lang t) (terpri)
         (generate-code (/ (* 1 3) (/ 2 4)) lang t) (terpri)
         (generate-code (/ (/ 1 3) 2) lang t) (terpri))
       #+end_src
***** code-generation for subs-node
****** description
       If the right node is a sum, we need to add parenthesis around it.
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code ((node subs-op)
                                 (lang infix-language)
                                 stream)
         (let* ((format-string (concatenate 'string
                                            "~a ~a "
                                            (if (or
                                                 (subtypep
                                                  (type-of (right node)) 'add-op)
                                                 (subtypep
                                                  (type-of (right node)) 'subs-op))
                                                "(~a)"
                                                "~a"))))
           ;; (format t "format string: ~a~%" format-string)

           (format stream format-string
                   (gcodenil left)
                   (gcodenil-exp (subs-symbol lang))
                   (gcodenil right))))
       #+END_SRC
****** test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'infix-language)))
         (bformat t "Testing code-generation for div node in infix-language")
         (generate-code (-  1 2) lang t) (terpri) 
         (generate-code (-  (+ 1 3) 2) lang t) (terpri)
         (generate-code (-  1 (+ 2 3)) lang t) (terpri)
         (generate-code (- (+ 1 3) (+ 2 4)) lang t) (terpri))
       #+end_src

    
*** symbol-separated-language
**** description
     A symbol-separated-language is a language like C or Java or GMPL where some the statements should end in a symbol.

**** class symbol-separated-language
***** description
      The class to represent the symbol-separated-language
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
      (defnode symbol-separated-language ()
        ((separator :accessor separator
                    :initarg :separator
                    :initform ";"
                    :documentation "The separator for the language")))
      #+END_SRC
**** code generation for the symbol-separated-language
***** description
      In the code-generation for this language we'll add an after method to those nodes that should end with a separator.  To avoid writing the same code over and over, we'll use a macro named =node-ends-with-separator=.
***** macro node-ends-with-separator
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
      (defmacro node-ends-with-separator (class-name language)
        `(defmethod generate-code :after ((node ,class-name)
                                          (lang ,language)
                                          stream)
                    (format stream "~a" (separator lang))))
      #+END_SRC
***** tests
****** simple test
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (progn
        (defclass disposable-test-class2 (infix-language
                                          symbol-separated-language)
          ())
        (node-ends-with-separator add-op disposable-test-class)
        (let* ((lang (make-instance 'disposable-test-class)))
          (bformat t "Testing code-generation for symbol-separated-language")
          (generate-code (+ 1 2) lang t)))
      #+end_src


*** camel-case-language
**** description
     A camel-case-language is a language with the convention that words in names will be separated by an uppercase letter as in upperCaseLanguage.

**** class camel-case-language
***** description
      The class to represent the camel-case-language
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
      (defnode camel-case-language ()
        ()
        :documentation "A language with camelCase notation.")
      #+END_SRC
**** code generation for the camel-case-language
***** description
      In the code-generation we'll only specialize in symbols, and will turn them into camel-case-expression.  To do that, we'll use a help function.
***** function symbol-to-camelcase
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defun symbol-to-camelcase (symbol)
         "Returns a string with the symbol-name of symbol in camelcase notation."
         (let* ((symbol-string (string-downcase (symbol-name symbol)))
                (camel-case-string "")
                (up-case nil))
           (if (> (length symbol-string) 1)
               (loop for c across symbol-string
                     when (not (char-equal c #\-))
                     do (setf camel-case-string
                              (concatenate 'string camel-case-string
                                           (if up-case (string-upcase c)
                                               (string c))))
                     do (setf up-case (char-equal c #\-)))
               (setf camel-case-string symbol-string))
           ;; return camel-case-string
           camel-case-string))
       #+END_SRC
****** tests
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (progn
        (bformat t "Testing symbol-to-camelcase")
        (format t "~a~%" (symbol-to-camelcase 'hello-world))
        (format t "~a~%" (symbol-to-camelcase 'hello))
        (format t "~a~%" (symbol-to-camelcase 'h)))
      #+end_src
***** generate-code for camel-case-language
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code ((node symbol)
                                 (language camel-case-language)
                                 stream)
         (format stream "~a" (symbol-to-camelcase node)))
       #+END_SRC
****** tests
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (make-instance 'camel-case-language)))
        (progn
          (bformat t "Testing symbol-to-camelcase")
          (generate-code 'hello-world lang t) (terpri)
          (generate-code 'hello lang t) (terpri)
          (generate-code 'h lang t) (terpri)))
      #+end_src


*** underscore-language
**** description
     An undescore-language is a language with the convention that words in names will be separated by an underscore as in underscore_language.

**** class underscore-language
***** description
      The class to represent the underscore_language.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
      (defnode underscore-language ()
        ()
        :documentation "A language with underscore_notation.")
      #+END_SRC
**** code generation for the underscore-language
***** description
      In the code-generation we'll only specialize in symbols, and will turn them into underscored_expressions.  To do that, we'll use a help function.
***** generic function convert-to-underscore
****** generic-function
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/generic-functions.lisp
       (defgeneric convert-to-underscore (obj)
         (:documentation "Returns a string with the obj in underscore_notation."))
       #+END_SRC
****** method (symbol)
******* code
        #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
        (defmethod convert-to-underscore ((obj symbol))
          "Returns a string with the symbol-name of symbol in underscore_notation."
          (let* ((current-string (symbol-name obj))
                 (underscored-string ""))
            (loop for c across current-string
                  do (setf underscored-string
                           (concatenate 'string
                                        underscored-string
                                        (if (char-equal c #\-) "_"
                                            (string c)))))
          ;; return underscored-string
          underscored-string))
        #+END_SRC
******* tests
        To make this simple test I'll create a disposable language
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (progn
         (bformat t "Testing symbol-to-underscore")
         (format t "~a~%" (convert-to-underscore 'hello-world))
         (format t "~a~%" (convert-to-underscore 'hello))
         (format t "~a~%" (convert-to-underscore 'h)))
       #+end_src
****** method (string)
******* code
        #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
        (defmethod convert-to-underscore ((string string))
          "If argument is a string, just replace dashes with underscores."
          (let* ((current-string string)
                 (underscored-string ""))
            (loop for c across current-string
                  do (setf underscored-string
                           (concatenate 'string
                                        underscored-string
                                        (if (char-equal c #\-) "_"
                                            (string c)))))
          ;; return underscored-string
          underscored-string))
        #+END_SRC
******* tests
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (progn
         (bformat t "Testing string-to-underscore")
         (format t "~a~%" (convert-to-underscore "hello-WORLD"))
         (format t "~a~%" (convert-to-underscore "hello"))
         (format t "~a~%" (convert-to-underscore "HELLO_WORLD")))
       #+end_src
***** generate-code for underscore-language
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code ((node t)
                                 (language underscore-language)
                                 stream)
         (format stream "~a" (convert-to-underscore node)))
       #+END_SRC
****** tests
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (make-instance 'underscore-language)))
        (progn
          (bformat t "Testing symbol-to-underscore")
          (generate-code 'hello-world lang t) (terpri)
          (generate-code 'hello lang t) (terpri)
          (generate-code 'h lang t) (terpri)))
      #+end_src
***** write-name for anything with =name=
****** description
       The function write-name assumes that the node it receives as parameter has a name.  In all those cases, the code generation is tha same.  If it is called with a node for which it is not defined a =name= method, it will signal an error.
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod write-name ((node t)
                              (lang t)
                              stream)
         (format stream "~a"
                 (convert-to-underscore 
                  (name node))))
       #+END_SRC
****** tests
******* tests with case insensitive language
        To make this simple test I'll create a disposable language
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'underscore-language)))
         (progn
           (bformat t "Testing write-name for underscore language")
           (write-name (var-ref 'hello-WORLD) lang t) (terpri)
           (write-name (variable-declaration-node 'Z-m-R) lang t) (terpri)
           (write-name (set-ref 's-1) lang t) (terpri)
           (write-name (set-declaration-node 'Set-1) lang t) (terpri)
           (write-name (param-ref 'p-1) lang t) (terpri)
           (write-name (parameter-declaration-node 'param-1) lang t) (terpri)
           ))
       #+end_src
******* tests with case sensitive language
        To make this simple test I'll create a disposable language
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (LET* ((lang (MAKE-INSTANCE 'UNDERSCORE-LANGUAGE)))
         (PROGN
           (BFORMAT T "Testing write-name for underscore language")
           (WRITE-NAME (VAR-REF 'hello-WORLD) lang T) (TERPRI)
           (WRITE-NAME (VARIABLE-DECLARATION-NODE 'Z-m-R) lang T) (TERPRI)
           (WRITE-NAME (SET-REF 's-1) lang T) (TERPRI)
           (WRITE-NAME (SET-DECLARATION-NODE 'Set-1) lang T) (TERPRI)
           (WRITE-NAME (PARAM-REF 'p-1) lang T) (TERPRI)
           (WRITE-NAME (PARAMETER-DECLARATION-NODE 'param-1) lang T) (TERPRI)
           ))
       #+end_src


*** variable-lowercase-language
**** description
     An variable-lowercase-language is a language with the convention that all the variable names are written in lowercase.

**** class variable-lowercase-language
***** description
      The class to represent the variable-lowercase-language.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
      (defnode variable-lowercase-language ()
        ()
        :documentation "A language with variable-lowercase convention.")
      #+END_SRC
**** code generation for the variable-lowercase-language
***** description
      In the code-generation we'll only specialize the function write-name in variables and var-refs, and will print the name of the variables as lowercase (with underscores, just in case).
***** write-name for var-ref
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod write-name ((node var-ref)
                              (lang variable-lowercase-language)
                              stream)
         (format stream "~a"
                 (convert-to-underscore 
                  (string-downcase (name node)))))
       #+END_SRC
****** tests
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (make-instance 'variable-lowercase-language)))
        (progn
          (bformat t "Testing variable-lowercase")
          (write-name (var-ref 'hello-WORLD) lang t) (terpri)
          (write-name (var-ref 'hello) lang t) (terpri)
          (write-name (var-ref 'h) lang t) (terpri)))
      #+end_src
***** write-name for variable-declaration
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod write-name ((node variable-declaration-node)
                              (lang variable-lowercase-language)
                              stream)
         (format stream "~a"
                 (convert-to-underscore 
                  (string-downcase (name node)))))
       #+END_SRC
****** tests
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (make-instance 'variable-lowercase-language)))
        (progn
          (bformat t "Testing variable-lowercase-language")
          (let* ((node1 (variable-declaration-node 'x))
                 (node2 (variable-declaration-node 'Y :var-type binary-variable))
                 (node3 (variable-declaration-node 'T
                                                   :var-type integer-variable
                                                   :lower-bound 1))
                 (node4 (variable-declaration-node 'Z123
                                                   :var-type binary-variable
                                                   :lower-bound 1
                                                   :upper-bound 10))
                 (node5 (variable-declaration-node 'T-x :var-type integer-variable
                                                   :lower-bound 1
                                                   :upper-bound 10
                                                   :domain 'H))
                 (node6 (variable-declaration-node 'X_ij :var-type continuous-variable
                                                   :lower-bound 1
                                                   :upper-bound 10
                                                   :domain `(H H)))
                 (node7 (variable-declaration-node 'Z-X-MM
                                                   :var-type binary-variable
                                                   :doc "A binary variable"))
                 )
    
          (write-name node1 lang t) (terpri)
          (write-name node2 lang t) (terpri)
          (write-name node3 lang t) (terpri)
          (write-name node4 lang t) (terpri)
          (write-name node5 lang t) (terpri)
          (write-name node6 lang t) (terpri)
          (write-name node7 lang t) (terpri)
          )))
      #+end_src
***** generate-code for var-ref
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code ((node var-ref)
                                 (lang variable-lowercase-language)
                                 stream)
         (format stream "~a"
                 (with-output-to-string (s)
                   (write-name node lang s))))
       #+END_SRC
****** tests
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (make-instance 'set-uppercase-language)))
        (progn
          (bformat t "Testing set-uppercase-language")
          (generate-code (set-ref 'hello-WORLD) lang t) (terpri)
          (generate-code (set-ref 'hello) lang t) (terpri)
          (generate-code (set-ref 'h) lang t) (terpri)))
      #+end_src


*** set-uppercase-language
**** description
     An set-uppercase-language is a language with the convention that all the set names are written in uppercase.

**** class set-uppercase-language
***** description
      The class to represent the set-uppercase-language.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
      (defnode set-uppercase-language ()
        ()
        :documentation "A language with set-uppercase convention.")
      #+END_SRC
**** code generation for the set-uppercase-language
***** description
      In the code-generation we'll only specialize in sets and set-refs, and in those casese will print the name of the sets in uppercase (and underscore, just in case).
***** write-name for set-ref
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod write-name ((node set-ref)
                              (language set-uppercase-language)
                              stream)
         (format stream "~a"
                 (convert-to-underscore 
                  (string-upcase (name node)))))
       #+END_SRC
****** tests
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (make-instance 'set-uppercase-language)))
        (progn
          (bformat t "Testing set-uppercase")
          (write-name (set-ref 'hello-world) lang t) (terpri)
          (write-name (set-ref 'hello) lang t) (terpri)
          (write-name (set-ref 'h) lang t) (terpri)))
      #+end_src
***** write-name for set-declaration
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod write-name ((node set-declaration-node)
                              (lang set-uppercase-language)
                              stream)
         (format stream "~a"
                 (convert-to-underscore 
                  (string-upcase (name node)))))
       #+END_SRC
****** tests
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (make-instance 'set-uppercase-language)))
        (progn
          (bformat t "Testing set-uppercase-language")
          (let* ((node1 (set-declaration-node 's))
                 (node2 (set-declaration-node 's1 :dimension 2))
                 (node3 (set-declaration-node 'S-12 :value '(1 2 3)))
                 (node4 (set-declaration-node 'S_ij :value '(1 2 3)
                                              :doc "A set documentation"))
                 (node5 (set-declaration-node 'xww :value (list (range 1 3)))))

          (write-name node1 lang t) (terpri)
          (write-name node2 lang t) (terpri)
          (write-name node3 lang t) (terpri)
          (write-name node4 lang t) (terpri)
          (write-name node5 lang t) (terpri)
          )))
      #+end_src
***** generate-code for set-ref
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/basic-language.lisp
       (defmethod generate-code ((node set-ref)
                                 (lang set-uppercase-language)
                                 stream)
         (format stream "~a"
                 (with-output-to-string (s)
                   (write-name node lang s))))
       #+END_SRC
****** tests
       To make this simple test I'll create a disposable language
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (make-instance 'variable-lowercase-language)))
        (progn
          (bformat t "Testing variable-lowercase")
          (generate-code (var-ref 'hello-WORLD) lang t) (terpri)
          (generate-code (var-ref 'hello) lang t) (terpri)
          (generate-code (var-ref 'h) lang t) (terpri)))
      #+end_src
    

** TODO writer-gmpl

*** description
    In this section I'll add the code-generation routines for gmpl.  The src blocks will be tangled to writer-gmpl.lisp.

    When we define the language we need to set the value of the operator-symbols for all the nodes the were not defined in basic-language.

    GMPL is a symbol-separated-language, infix-language and we'll follow the underscore-language.

    In the definition of the class I'll add the missing operators from basic-language.

    The value of the remaining operators will be added in the constructor, and we'll use defclass instead of defnode to avoid the automatic creation of a constructor.

    Because we are adding the slots in the constructor, this class should never be instantiated using a =make-instance=.

*** add the package to the file
    #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
    (in-package :lmml)
    #+END_SRC
*** define the language
**** description
     The value of the remaining operators will be added in the constructor, and we'll use defclass instead of defnode to avoid the automatic creation of a constructor.

    Because we are adding the slots in the constructor, this class should never be instantiated using a =make-instance=.
**** code
     #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
     (defclass gmpl-language (infix-language
                              symbol-separated-language
                              underscore-language
                              ;; variable-lowercase-language
                              ;; set-uppercase-language
                              )
       ())

     (defun gmpl-language ()
       (make-instance 'gmpl-language
                      :union-symbol "union"
                      :intersection-symbol "inter"
                      :assignment-symbol "="
                      :difference-symbol "diff"
                      :cartesian-product-symbol "cross"))
     #+END_SRC
**** constant
     #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
     (defparameter gmpl (gmpl-language))
     #+END_SRC
**** tests
    #+begin_src lisp :results output :export code :tangle src/tests.lisp
    (let* ((lang (gmpl-language)))
      (progn
        (bformat t "Testing operations in gmpl-language.")
        (generate-code (union-op 'A 'B) lang t) (terpri)
        (generate-code (intersection-op 'A 'B) lang t) (terpri)
        (generate-code (assignment-op 'A 'B) lang t) (terpri)
        (generate-code (difference-op 'A 'B) lang t) (terpri)
        (generate-code (cartesian-product-op 'A 'B) lang t) (terpri)))
    #+end_src

    #+RESULTS:
    : ======================================
    :  Testing operations in gmpl-language.
    : ======================================
    : 
    : A union B
    : A inter B
    : A = B
    : A diff B
    : A cross B

*** code generation
**** description
     In this section we add the code snippets for the code-generation in GMPL.  
**** +binary-operations+ (DONE by infix-language)
**** is-a-reference
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (gcode is-a-reference gmpl-language ("~a") (name))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language)))
       (progn
         (bformat t "Testing is-a-reference in gmpl-language.")
         (generate-code (var-ref "A") lang t) (terpri)))
     #+end_src
     
**** index-at
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (defmethod generate-code((node index-at)
                               (lang gmpl-language)
                               (stream t))

        (let* ((indexes-code (mapcar (lambda (x) (generate-code x lang nil))
                                     (indexes node))))
          (format stream "~a[~{~a~^, ~}]"
                  (gcodenil var-name)
                  indexes-code)))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language)))
       (progn
         (bformat t "Testing index-at in gmpl-language.")
         (generate-code (index-at "x" 1 2 3) lang t) (terpri)))
     #+end_src
**** for-all-quantifier
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (gcode for-all-quantifier gmpl-language ("~a in ~a") (var-name set-name))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language)))
       (progn
         (bformat t "Testing for-all in gmpl-language.")
         (generate-code (for-all-quantifier  "i" "I" nil) lang t) (terpri)
         (generate-code (for-all-quantifier  "i" "I" (< "i" 5)) lang t) (terpri)))
     #+end_src

**** +variable-reference+ (DONE by is-a-reference)
**** var-in-set
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (gcode var-in-set gmpl-language ("~a in ~a") (var-name set-name))
      #+END_SRC
***** tests
****** simple test
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (gmpl-language))
             (node1 (var-in-set 'i 'J))
             (node2 (var-in-set "i" "J"))
             (i (var-ref "i"))
             (s-decl (set-declaration-node "S"))
             (S (set-ref "S" s-decl))
             (node3 (var-in-set i S))
             )
        (progn
          (bformat t "Testing sum-node in gmpl-language.")
          (generate-code node1 lang t)  (terpri)
          (generate-code node2 lang t)  (terpri)
          (generate-code node3 lang t)  (terpri)
          ))
      #+end_src

**** var-from-to
***** description
      To generate the code for a var-from-to node in gmpl, we need to first create a set, and then convert the node to a var-in-set node that uses that set.  We won't do that at this moment.  That's why, for now, we'll rise an error when trying to generate-code for a var-from-to node in gmpl.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (defmethod generate-code ((node var-from-to)
                                (lang gmpl-language)
                                stream)
        (error "In GMPL we can't generate the code (yet) for var-from-to nodes :-(."))
      #+END_SRC
***** tests
****** simple test (raises an error)
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (gmpl-language))
             (node1 (var-from-to 'i 1 10))
             )
        (progn
          (bformat t "Testing sum-node in gmpl-language.")
          (generate-code node1 lang t)  (terpri)
          ))
      #+end_src

**** sum-node
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (defmethod generate-code ((node sum-node)
                                (lang gmpl-language)
                                stream)
        (format stream "sum {~{~a~^, ~}} ~a"
                (mapcar (lambda (x) (gcodenil-exp x))
                        (sum-bounds node))
                    (gcodenil elements)))

      #+END_SRC
***** tests
****** tests with sum-node
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (gmpl-language))
             (s-one (set-ref 's-one))
             (node1 (sum-node (list (var-in-set i s-one)) "i"))
             (node2 (sum-node (list (var-in-set i s-one)
                                    (var-in-set j s-one))
                              (+ 'i 'j)))
             )
        (progn
          (bformat t "Testing sum-node in gmpl-language.")
          (generate-code node1 lang t) (terpri)
          (generate-code node2 lang t) (terpri)
          ))
      #+end_src
****** tests with sumf
      #+begin_src lisp :results output :export code :tangle src/tests.lisp
      (let* ((lang (gmpl-language))
             (s-one (set-ref 's-one))
             (node1 (sumf ((i in s-one)) i))
             (node2 (sumf ((i in s-one)
                           (j in s-one))
                          (+ i j)))
             (node3 (sumf ((i in s-one)
                           (< i 5))
                          (+ i 2)))
             )
        (progn
          (bformat t "Testing sum-node in gmpl-language.")
          (generate-code node1 lang t) (terpri)
          (generate-code node2 lang t) (terpri)
          (generate-code node3 lang t) (terpri)
          ))
      #+end_src

      #+RESULTS:
      : ====================================
      :  Testing sum-node in gmpl-language.
      : ====================================
      : 
      : sum {I in S_ONE} I
      : sum {I in S_ONE, J in S_ONE} I + J
      : sum {I in S_ONE, I < 5} I + 2

****** expect error
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (gmpl-language)))
        (progn
          (bformat t "Testing sum-node in gmpl-language.")
          (generate-code (sumf ((i from 1 to 5)) 'i) lang t)
          (terpri)))
      #+end_src
**** constraint-node
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (node-ends-with-separator constraint-node gmpl-language)
      (gcode constraint-node gmpl-language
             ("s.t. ~a~a: ~a")
             (id (if (quantifiers node)
                          (format nil " {~{~a~^, ~}}"
                                  (mapcar (lambda (x)
                                            (gcodenil-exp x))
                                          (quantifiers node)))
                          "")
                 func))

      #+END_SRC
***** tests
****** basic test
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (gmpl-language)))
        (progn
          (bformat t "Testing constraint-node in gmpl-language.")
          (generate-code (constraint-node 1 (<= "x" 5)) lang t)
          (terpri)
          (generate-code (constraint-node "r" (<= (index-at "x" 1 "j") 5)
                                          :quantifiers
                                          (list (for-all-quantifier "j" "J" nil)))
                         lang t)
          (terpri)
          (generate-code (constraint-node "r" (<= (index-at "x" 1 "j" "k") 5)
                                          :quantifiers
                                          (list (for-all-quantifier "j" "J" nil)
                                                (for-all-quantifier "k" "K" nil)))
                         lang t)
          (terpri)
          ))
      #+end_src
****** tests to fix constraint
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (make-instance 'gmpl-language)))
         (bformat t "Finding bug in code-generation for constraint")
         (set i1 :value (range 1 5))
         (variable-declaration y1 :domain {i1 i1})
         (setf c1 (constraint "c1" (= (sumf ((b in I1)) [y1 0 b]) 5)))

         (generate-code c1 lang t)
         )
       #+end_src
**** continuous-variable-type
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (gcode continuous-variable-type gmpl-language (""))

      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language)))
       (progn
         (bformat t "Testing continuous-variable-type in gmpl-language.")
         (generate-code (continuous-variable-type) lang t)
         (terpri)))
     #+end_src

**** integer-variable-type
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (gcode integer-variable-type gmpl-language (", integer"))

      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language)))
       (progn
         (bformat t "Testing integer-variable-type in gmpl-language.")
         (generate-code (integer-variable-type) lang t)
         (terpri)))
     #+end_src

**** binary-variable-type
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (gcode binary-variable-type gmpl-language (", binary"))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language)))
       (progn
         (bformat t "Testing binary-variable-type in gmpl-language.")
         (generate-code (binary-variable-type) lang t)
         (terpri)))
     #+end_src

**** variable-declaration-node
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (node-ends-with-separator variable-declaration-node gmpl-language)
      (gcode variable-declaration-node gmpl-language
             ("var ~a~a~a~a~a")
             ((gcodenil-exp (write-name node lang nil))
              (if (domain node)
                  (let* ((var-name-generator
                          (make-dummy-variable-name-generator t)))
                    (format nil " {~{~a~^, ~}}"
                            (mapcar (lambda (x)
                                      (concatenate
                                       'string
                                       (string-downcase
                                        (funcall var-name-generator))
                                       " in "
                                       (generate-code x lang nil)))
                                    (domain node))))
                  "")
              var-type
              (if (and (lower-bound node))
                  (format nil ", >= ~a"
                          (gcodenil lower-bound))
                  "")
              (if (and (upper-bound node)
                       (/= (upper-bound node) 0))
                  (format nil ", <= ~a"
                          (gcodenil upper-bound))
                  "")))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language)))
       (progn
         (bformat t "Testing variable-declaration-node in gmpl-language.")
         (let* ((node1 (variable-declaration-node 'x))
                (node2 (variable-declaration-node 'Y :domain '(I)))
                (node3 (variable-declaration-node 'Z12 :domain '(I I)))
                (node4 (variable-declaration-node 'TEMP :domain '(I I)
                                                  :var-type integer-variable))
                (node5 (variable-declaration-node 'x123 :domain '(I I)
                                                  :var-type binary-variable))
                (node6 (variable-declaration-node 'x-f-y :domain '(I I)
                                                  :var-type continuous-variable))
                (node7 (variable-declaration-node 'x-1234 :domain '(I I)
                                                  :var-type continuous-variable
                                                  :lower-bound 1))
                (node8 (variable-declaration-node 'x_ij :domain '(I I)
                                                  :var-type continuous-variable
                                                  :upper-bound 10))
                (node9 (variable-declaration-node 'Q_mn :domain '(I I)
                                                  :var-type continuous-variable
                                                  :lower-bound 5
                                                  :upper-bound 10)))
           (generate-code node1 lang t) (terpri)
           (generate-code node2 lang t) (terpri)
           (generate-code node3 lang t) (terpri)
           (generate-code node4 lang t) (terpri)
           (generate-code node5 lang t) (terpri)
           (generate-code node6 lang t) (terpri)
           (generate-code node7 lang t) (terpri)
           (generate-code node8 lang t) (terpri)
           (generate-code node9 lang t) (terpri))))
     #+end_src
**** objective-function-node
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (node-ends-with-separator objective-function-node gmpl-language)
      (gcode objective-function-node gmpl-language
             ("~a ~a: ~a")
             (obj id func))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language)))
       (progn
         (bformat t "Testing objective-function in gmpl-language.")
         (let* ((node1 (objective-function-node "goal" (+ "x" 5) :id "obj1"))
                (node2 (minimize "obj2" (+ (* "x" 5) (* "y" 6))))
                (node3 (maximize "obj3" (+ (* "x" 5) (* "y" 6)))))
           (generate-code node1 lang t) (terpri)
           (generate-code node2 lang t) (terpri)
           (generate-code node3 lang t) (terpri))))
     #+end_src
**** +maximize+ (DONE by the objective-function-node)
**** +minimize+ (DONE by the objective-function-node)
**** +instructions-list+ (DONE by the basic-language)
**** problem-definition-node
***** version 2
****** description
       In this version we'll idenitify the data-sections and add them at the end.
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
       (defmethod generate-code ((node problem-definition-node)
                                 (lang gmpl-language)
                                 stream)
         (let* (data-section
                elements-without-data
                instructions-without-data)
           ;; first we detect if there is a data section
           (loop for elt in (elements (instr node))
                 do (progn
                      (if (is-a-data-section elt)
                          ;; then
                          (setf data-section elt)
                          ;; else
                          (push elt elements-without-data))))
    
           ;; let's reverse the data
           (setf instructions-without-data
                 (instructions-list
                  (reverse elements-without-data)))

           (format stream "~a"
                   (with-output-to-string (s)
                     (format s "/*Problem ~a*/~3%"
                             (gcodenil name))
                     (format s "~a~2%"
                             (gcodenil-exp instructions-without-data))

                     (if data-section
                         (format s "~a~%"
                                 (gcodenil-exp data-section )))

                     (format s "end;~%")))))
       #+END_SRC
****** tests
******* simple test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (gmpl-language)))
         (progn
           (bformat t "Testing problem-definition-node in gmpl-language.")
           (let* ((p1 (problem-node "example 1"  1 2 3 4))
                  (p2 (problem-node "example 2"  1 2 (data-section 'a 'b) 3 4)))
             (generate-code p1 lang t) (terpri)
             (generate-code p2 lang t) (terpri))))
       #+end_src
******* test with an actual problem
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (gmpl-language)))
         (progn
           (bformat t "Testing an actual problem in gmpl-language.")
           (let* ()
             (generate-code example1 lang t))))
       #+end_src
***** version 1
****** description
       This is the simplest code generation for a problem.  It should be superseded soon.
****** code
       #+BEGIN_SRC lisp +n -r :results none :exports none
       (gcode problem-definition-node gmpl-language
              ("/*Problem ~a*/~3%~a~%end;~%")
              (name instr))
       #+END_SRC
****** tests
******* simple test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (gmpl-language)))
         (progn
           (bformat t "Testing problem-definition-node in gmpl-language.")
           (let* ((p1 (problem-node "example 1"  1 2 3 4)))
             (generate-code p1 lang t))))
       #+end_src
******* test with an actual problem
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (gmpl-language)))
         (progn
           (bformat t "Testing an actual problem in gmpl-language.")
           (let* ()
             (generate-code example1 lang t))))
       #+end_src
**** +parameter-reference+ (DONE by is-a-reference)
**** parameter-declaration-node
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (node-ends-with-separator parameter-declaration-node gmpl-language)
      (gcode parameter-declaration-node gmpl-language
             ("param ~a~a~a")
             (name
              (if (domain node)
                  (let* ((var-name-generator
                          (make-dummy-variable-name-generator t)))
                    (format nil " {~{~a~^, ~}}"
                            (mapcar (lambda (x)
                                      (concatenate 'string
                                                   (string-downcase
                                                    (funcall var-name-generator))
                                                   " in "
                                                   (generate-code x lang nil)))
                                    (domain node))))
                  "")
              (cond
                ((null (value node))
                 (format nil ""))
                ((listp (value node))
                 (format nil " := ~{~a~^, ~}"
                         (mapcar (lambda (x)
                                   (generate-code x lang nil))
                                 (value node))))
                (t (format nil " := ~a"
                           (generate-code (value node) lang nil))))))
      #+END_SRC
***** tests
****** layer 1
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (gmpl-language))
             (node1 (parameter-declaration-node 'p))
             (node2 (parameter-declaration-node 'P :domain '(I)))
             (node3 (parameter-declaration-node 'P :domain '(I J)))
             (node4 (parameter-declaration-node 'P :value 5))
             (node5 (parameter-declaration-node 'P :value 5
                                                :doc "A documentation")))
        (bformat t "Testing parameter-declaration node")
        (generate-code node1 lang t) (terpri) 
        (generate-code node2 lang t) (terpri)
        (generate-code node3 lang t) (terpri)
        (generate-code node4 lang t) (terpri)
        (generate-code node5 lang t) (terpri))
      #+end_src
****** layer 2
******* simple test
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (gmpl-language))
              (node1 (parameter p))
              (node2 (parameter P :domain '(I)))
              (node3 (parameter P :domain '(I J)))
              (node4 (parameter P :value 5))
              (node5 (parameter P :value 5
                                :doc "A documentation")))
         (bformat t "Testing parameter-declaration node")
         (generate-code node1 lang t) (terpri) 
         (generate-code node2 lang t) (terpri)
         (generate-code node3 lang t) (terpri)
         (generate-code node4 lang t) (terpri)
         (generate-code node5 lang t) (terpri))
       #+end_src
******* tests with sets
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (gmpl-language))
              (s1-decl (set-declaration-node "s-test"))
              (s1 (set-ref "s-test" s1-decl))
              (node1 (parameter p))
              (node2 (parameter P :domain (list s1)))
              (node3 (parameter P :domain (list s1 s1)))
              (node4 (parameter P :value 5))
              (node5 (parameter P :value 1
                                :doc "A documentation")))
         (bformat t "Testing parameter-declaration node")
         (generate-code node1 lang t) (terpri) 
         (generate-code node2 lang t) (terpri)
         (generate-code node3 lang t) (terpri)
         (generate-code node4 lang t) (terpri)
         (generate-code node5 lang t) (terpri))
       #+end_src
**** range-node
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (gcode range-node gmpl-language
             ("~a..~a~a")
             (min-value
              max-value
              (if (and (numberp (increment node))
                       (/= (increment node) 1))
                  (format nil " by ~a"
                          (gcodenil increment))
                  "")))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language))
            (node1 (range 1 5))
            (node2 (range 1 5 :increment 2)))

       (bformat t "Testing code-generation for range-node")
       (generate-code node1 lang t) (terpri)
       (generate-code node2 lang t) (terpri))
     #+end_src
**** +set-reference+ (DONE by is-a-reference)
**** set-declaration-node
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (node-ends-with-separator set-declaration-node gmpl-language)
      (gcode set-declaration-node gmpl-language
             ("set ~a~a~a")
             ((gcodenil-exp (write-name node lang nil))
              (if (dimension node)
                  (format nil " dimen ~a"
                          (gcodenil dimension))
                  "")
              (if (value node)
                  (cond
                    ((subtypep (class-of (first (value node)))
                               'range-node)
                     (format nil " := ~a"
                             (generate-code (first (value node)) lang nil)))
                    (t (format nil " := {~{~a~^,~}}"
                               (mapcar (lambda (x)
                                         (gcodenil-exp x))
                                       (value node))))
                    )
                  "")))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language))
            (node1 (set-declaration-node 's))
            (node2 (set-declaration-node 'S1 :dimension 2))
            (node3 (set-declaration-node 'S-max :value '(1 2 3)))
            (node4 (set-declaration-node 'xvM :value '(1 2 3)
                                         :doc "A set documentation"))
            (node5 (set-declaration-node 'T12 :dimension (+ 1 1)))
            (node6 (set-declaration-node 'TS_45p :value (list 1 (+ 1 1) 3)))
            (node7 (set-declaration-node 'S12_O-12 :value (list (range 1 3)))))

       (bformat t "Testing set-declaration code generation")
       (generate-code node1 lang t) (terpri)
       (generate-code node2 lang t) (terpri)
       (generate-code node3 lang t) (terpri)
       (generate-code node4 lang t) (terpri)
       (generate-code node5 lang t) (terpri)
       (generate-code node6 lang t) (terpri)
       (generate-code node7 lang t) (terpri))
     #+end_src
**** display-node
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (node-ends-with-separator display-node gmpl-language)
      (gcode display-node gmpl-language
             ("display ~a") (element))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language))
            (x (var-ref "x"))
            (node1 (display 1))
            (node2 (display x))
            (node3 (display (+ 1 x))))

       (bformat t "Testing code-generation for display-node")
       (generate-code node1 lang t) (terpri)
       (generate-code node2 lang t) (terpri)
       (generate-code node3 lang t) (terpri))
     #+end_src
**** solve-node
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (node-ends-with-separator solve-node gmpl-language)
      (gcode solve-node gmpl-language
             ("solve") ())
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language))
            (node1 (solve)))

       (bformat t "Testing code-generation for solve-node")
       (generate-code node1 lang t) (terpri))
     #+end_src
**** has-doc
***** description
      When an element has the doc property, we'll add it as a comment line before the actual code generation.  We'll do that using a before method.  We'll also add and extra line before adding the documentation.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (defmethod generate-code :before ((node has-doc)
                                        (lang gmpl-language)
                                        stream)
        (if (doc node)
            (format stream "/* ~a */~%" (doc node))))

      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language))
            (node1 (variable-declaration-node "X1"
                                              :doc "A documented variable"))
            (node2 (parameter-declaration-node "p1"
                                              :doc "A documented parameter"))
            (node3 (set-declaration-node "s1"
                                         :doc "A documented set"))
            (node4 (constraint-node "r1" (<= (+ "x" 1) 5)
                                              :doc "A documented constraint")))

       (bformat t "Testing code-generation for has doc")
       (generate-code node1 lang t) (terpri)
       (generate-code node2 lang t) (terpri)
       (generate-code node3 lang t) (terpri)
       (generate-code node4 lang t) (terpri)
       )
     #+end_src
**** data-readers
***** standard-data-reader
****** description
       In this section I'll write the code of the methods of the generic-function format-value-of for the standard-data-reader and the nodes set-value-of-set and set-value-of-param.

****** method for set-value-of-set and list
******* description
        The standard-data-reader method assumes that the sets always have dimension one, and here we code what happens when the value is a list.  In GMPL that type of set is represented as a list.

******* code
        #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
        (defmethod format-value-of ((node set-value-of-set)
                                    (value list)
                                    (lang gmpl-language)
                                    (data-reader standard-data-reader)
                                    stream)
          (format stream "~a"
                    (with-output-to-string (s)
                      (format s "~{~a~^, ~}"
                              (mapcar (lambda (x) (gcodenil-exp x))
                                      value)))))

        #+END_SRC
******* tests
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (gmpl-language))
              (dreader +standard-data-reader+)
              (set-decl (set-declaration-node "S1"
                                              :doc "A documented set"))
              (s1 (set-ref "S1" set-decl))
              (node1 (set-value-of-set s1 '(1 2 3 4 5)))
              (node2 (set-value-of-set s1 '(one two three)))
              (node3 (set-value-of-set s1 '("one" "two" "three"))))

         (bformat t "Testing format-value-of set with standard-data-reader")
         (format-value-of node1 (value node1) lang dreader t) (terpri)
         (format-value-of node2 (value node2) lang dreader t) (terpri)
         (format-value-of node3 (value node3) lang dreader t) (terpri)
         )
       #+end_src
****** method for set-value-of-set and range
******* description
        The standard-data-reader method assumes that the sets always have dimension one, and in this section we specialize it for the case that the value is of type =range=.

******* code
        #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
        (defmethod format-value-of ((node set-value-of-set)
                                    (value range-node)
                                    (lang gmpl-language)
                                    (data-reader standard-data-reader)
                                    stream)
          (format stream "~a" (gcodenil-exp value)))

        #+END_SRC
******* tests
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (gmpl-language))
              (dreader +standard-data-reader+)
              (set-decl (set-declaration-node "S1"
                                              :doc "A documented set"))
              (s1 (set-ref "S1" set-decl))
              (node1 (set-value-of-set s1 (range 1 5)))
              (node2 (set-value-of-set s1 (range 1 10 :increment 2))))

         (bformat t "Testing format-value-of set with standard-data-reader")
         (format-value-of node1 (value node1) lang dreader t) (terpri)
         (format-value-of node2 (value node2) lang dreader t) (terpri)
         )
       #+end_src
****** method for set-value-of-param and number
******* description
        This is the case where we have a one dimensional parameter and we are assigning a value to that parameter.

******* code
        #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
        (defmethod format-value-of ((node set-value-of-param)
                                    (value number)
                                    (lang gmpl-language)
                                    (data-reader standard-data-reader)
                                    stream)
          (format stream "~a" (gcodenil-exp value)))

        #+END_SRC
******* tests
       #+begin_src lisp :results none :export code :tangle src/tests.lisp
       (let* ((lang (gmpl-language))
              (dreader +standard-data-reader+)
              (param-decl (parameter-declaration-node "p1"
                                              :doc "A documented param"))
              (p1 (param-ref "p1" param-decl))
              (node1 (set-value-of-param p1 6)))

         (bformat t "Testing format-value-of param with standard-data-reader")
         (format-value-of node1 (value node1) lang dreader t) (terpri)
         )
       #+end_src
****** method for set-value-of-param and list
******* description
        This is the case where we have a parameter with a one dimensional index.  In this case, the value of the set in the parameter should be already set.

        I'll use the format of printing each value on a line.

        In this case, we should get something like:

        #+begin_example
        (set-value-of-param D :value {1 2 3 4})
        #+end_example

        And then the parameter =D= should be indexed in a set with cardinality 4.

******* code
        #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
        (defmethod format-value-of ((node set-value-of-param)
                                    (value list)
                                    (lang gmpl-language)
                                    (data-reader standard-data-reader)
                                    stream)


          (let* ((param-ref (param-name node))
                 (param-decl (original-declaration param-ref))
                 (current-domain (domain param-decl))
                 ;; let's compute the length of `param name :='
                 (name-length (length (name param-ref)))
                 (indentation (cl:+ 9 name-length))
                 (indentation-str (make-string indentation
                                               :initial-element #\SPACE)))
            ;; from here on we differentiate according the dimension of
            ;; the domain

            (cond
              ;; dimension 1
              ((cl:= (length current-domain) 1)
               (let* ((domain-value (current-value (first current-domain)))
                      (max-name-length (loop for e in domain-value
                                             maximizing (length (name e))))
                      (column-for-value max-name-length))
                 ;; check that the value and the domain have the same
                 ;; cardinality

                 (if (cl:/= (length domain-value)
                            (length value))
                     (error "Error in set-value-of-param: Parameter value and domain set should have the same number of elements."))
                 ;; everything is ok, so
                 ;; let's print the first two elements:
                 (format stream "~a"
                         (with-output-to-string (s)
                           (format s "~a~vT~a"
                                   (gcodenil-exp (first domain-value))
                                   (1+ column-for-value)
                                   (gcodenil-exp (first value))
                                   ;; debug
                                   ;; (1+ column-for-value)
                                   ;; max-name-length
                                   )
                           (loop for index-value in (rest domain-value)
                                 for param-value in (rest value)
                                 do (format s "~%")
                                 do (format s "~a ~a~vT~a"
                                            indentation-str
                                            (gcodenil-exp index-value)
                                            (cl:+ column-for-value
                                                  indentation
                                                  ;; add the whitespaces? :-/
                                                  2)
                                            (gcodenil-exp param-value)
                                            ;;debug
                                            ;;(cl:+ column-for-value
                                            ;;       indentation
                                            ;;       2)
                                            ))))))
              ;; dimension 2
              ;; TODO: give space according to size of the
              ;; numbers in the data.
              ((cl:= (length current-domain) 2)
               (let* ((domain-value-1 (current-value (first current-domain)))
                      (domain-value-2 (current-value (second current-domain)))
                      (max-name-length-in-set-1
                       (loop for e in domain-value-1
                             maximizing (length (name e))))
                      (column-for-first-column
                       (cl:+ 2 max-name-length-in-set-1))
                      (column-positions
                       (make-array (list (length domain-value-2)))))
                 ;; check that the value and the domain have the same
                 ;; cardinality
                 ;; TODO 
                 ;; everything is ok, so

                 (format stream "~a"
                         (with-output-to-string (s)
                           ;; the position of the first value is
                           ;; the column for the first column
                           (setf (aref column-positions 0)
                                 (cl:+ column-for-first-column
                                       indentation))

                           ;; let's print the names of the second set 
                           (format s "~a~a"
                                   (make-string column-for-first-column
                                                :initial-element #\SPACE)
                                   (gcodenil-exp (first domain-value-2)))

                           ;; add the names of the second set
                           ;; and compute the columns positions
                           (loop for e in (rest domain-value-2)
                                 for l in domain-value-2
                                 for i from 1
                                 do (format s " ~a"
                                            (gcodenil-exp e))
                                 do (setf (aref column-positions i)
                                          (cl:+ (aref column-positions (1- i))
                                                (length l)
                                                1)))
                           ;; finally let's add the symbol := and the newline
                           (format s " :=")

                           ;; now let's print each line
                           (loop for set-value1 in domain-value-1
                                 for i from 0
                                 for row in value
                                 do (format s "~%")
                                 do (format s "~a~a"
                                            indentation-str
                                            (gcodenil-exp set-value1))
                                 ;; now let's add the data
                                 do (loop for elt in row
                                          for p from 0
                                          do (format s "~vT~a"
                                                     (aref column-positions p)
                                                     elt)))

                           ;; (loop for index-value in (rest domain-value)
                           ;;       for param-value in (rest value)
                           ;;       do (format s "~%")
                           ;;       do (format s "~a ~a~vT~a"
                           ;;                  indentation-str
                           ;;                  (gcodenil-exp index-value)
                           ;;                  (cl:+ column-for-value
                           ;;                        indentation
                           ;;                        ;; add the whitespaces? :-/
                           ;;                        2)
                           ;;                  (gcodenil-exp param-value)
                           ;;                  ;;debug
                           ;;                  ;;(cl:+ column-for-value
                           ;;                  ;;       indentation
                           ;;                  ;;       2)
                           ;;                  ))
                           ))))
              )))
        #+END_SRC
******* tests
******** test for 1 dimensional data
        #+begin_src lisp :results none :export code :tangle src/tests.lisp
        (let* ((lang (gmpl-language))
               (s (set-declaration-node "S" :value {1 2 3 }
                                        :current-value {1 2 3 }))
               (dreader +standard-data-reader+)
               (param-decl (parameter-declaration-node "parametro_importante"
                                                       :domain {s}))
               (p1 (param-ref "parametro_importante" param-decl))
               (node1 (set-value-of-param p1 {10 20 30})))

          (bformat t "Testing format-value-of param with standard-data-reader")
          (format-value-of node1 (value node1) lang dreader t) (terpri)
          )
        #+end_src
******** test for 2 dimensional data
        #+begin_src lisp :results none :export code :tangle src/tests.lisp
        (let* ((lang (gmpl-language))
               (s1-decl (set-declaration-node
                         "S1" :value '(city province country)
                         :current-value '(city province country)))
               (s2-decl (set-declaration-node
                         "S2" :value '(havana miami bombay london)
                         :current-value '(havana miami bombay london)))
               (s1 (set-ref "S1" s1-decl))
               (s2 (set-ref "S2" s2-decl))
               (dreader +standard-data-reader+)
               (param-decl (parameter-declaration-node "parametro_importante"
                                                       :domain {s1 s2}))
               (p1 (param-ref "parametro_importante" param-decl))
               (node1 (set-value-of-param p1 '((1 2 3 4)
                                               (5 6 7 8)
                                               (1 3 5 7)))))

          (bformat t "Testing format-value-of param with standard-data-reader")
          (format-value-of node1 (value node1) lang dreader t) (terpri)
          )
        #+end_src
**** set-value-of-set
***** description
      The code generation of the set-value-of-set node will be done using the data-readers and the generic function =format-value-of=.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (node-ends-with-separator set-value-of-set gmpl-language)

      (gcode set-value-of-set gmpl-language ("set ~a := ~a")
             (set-name
              (gcodenil-exp
               (format-value-of node
                                (value node)
                                lang
                                (data-reader node)
                                nil))))

      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((lang (gmpl-language))
            (set-decl (set-declaration-node "S1"
                                            :doc "A documented set"))
            (s1 (set-ref "S1" set-decl))
            (node1 (set-value-of-set s1 '(1 2 3 4 5)))
            (node2 (set-value-of-set s1 '(one two three)))
            (node3 (set-value-of-set s1 '("one" "two" "three")))
            (node4 (set-value-of-set s1 (range 5 10)))
            (node5 (set-value-of-set s1 (range 5 10 :increment 2))))

       (bformat t "Testing generate-code for set-value-of-set")
       (generate-code node1 lang t) (terpri)
       (generate-code node2 lang t) (terpri)
       (generate-code node3 lang t) (terpri)
       (generate-code node4 lang t) (terpri)
       (generate-code node5 lang t) (terpri)
       )
     #+end_src
**** set-value-of-param
***** description
      The code generation of the set-value-of-param node will be done using the data-readers and the generic function =format-value-of=.
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (node-ends-with-separator set-value-of-param gmpl-language)

      (defmethod generate-code ((node set-value-of-param)
                                (lang gmpl-language)
                                stream)

        (let* ((param (param-name node))
               (current-domain (domain param))
               (dimension (length current-domain)))

          (format stream "param ~a ~a ~a"
                  (gcodenil param-name)
                  (if (cl:< dimension 2) ":=" ":")
                  (format-value-of node
                                   (value node)
                                   lang
                                   (data-reader node)
                                   nil))))
      #+END_SRC
***** tests
****** tests for 1d lists
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (gmpl-language))
             (param-decl (parameter-declaration-node "p1"))
             (p1 (param-ref "p1" param-decl))
             (node1 (set-value-of-param p1 6))
             (sdecl (set-declaration-node "S" :value {1 2 3}
                                          :current-value {1 2 3}))
             (s (set-ref "S" sdecl))
             (param-decl2 (parameter-declaration-node "parameter2"
                                                      :domain {s}))
             (parameter2 (param-ref "parameter2" param-decl2))
             (node2 (set-value-of-param parameter2 '(one two three)))
             (param-decl3 (parameter-declaration-node "p3"
                                                      :domain {s}))
             (p3 (param-ref "p3" param-decl3))
             (node3 (set-value-of-param p3 '("one" "two" "three")))
             (s2decl (set-declaration-node "S2" :value {1}))
             (s2 (set-ref "S2" s2decl))
             (param-decl4 (parameter-declaration-node "p444"
                                                      :domain {s2}))
             (p444 (param-ref "p444" param-decl4))
             (node4 (set-value-of-param p444 {100}))
             (s3decl (set-declaration-node
                      "S3" :value {"Habana" "Mayabeque" "Pinar" "Guantanamo"}))
             (s3 (set-ref "S3" s3decl))
             (param-decl5 (parameter-declaration-node "p5"
                                                      :domain {s3}))
             (p5 (param-ref "p5" param-decl5))
             (node5 (set-value-of-param p5 {1 5 10 20}))
             )

        (bformat t "Testing generate-code for set-value-of-param")

        (format t "value of sdecl: ~a~%" (current-value sdecl))

        (format t "Just set a number:~%")
        (generate-code node1 lang t) (terpri)
        (format t "~%Assign a list:~%")
        (generate-code node2 lang t) (terpri)(terpri)
        ;; (generate-code node3 lang t) (terpri)(terpri)
        ;; (generate-code node4 lang t) (terpri)(terpri)
        ;; (generate-code node5 lang t) (terpri)(terpri)
        )
      #+end_src
****** tests for 2d lists
      #+begin_src lisp :results none :export code :tangle src/tests.lisp
      (let* ((lang (gmpl-language))
             (s1decl (set-declaration-node
                      "S1" :value {"Newton" "Salgari"}
                      :current-value {"Newton" "Salgari"}))
             (s1 (set-ref "S1" s1decl))

             (s2decl (set-declaration-node
                      "S2"
                      :value {"Habana" "Mayabeque" "Pinar" "Guantanamo"}
                      :current-value {"Habana" "Mayabeque" "Pinar" "Guantanamo"}))

             (s2 (set-ref "S2" s2decl))
             (param-decl1 (parameter-declaration-node 
                           "p1" :domain {s1 s2}))
             (p1 (param-ref "p1" param-decl1))
             (node1 (set-value-of-param p1 '((1 2 3 4)
                                             (5 6 7 8))))

             (s3decl (set-declaration-node
                      "S3" :value {1 2 3}
                      :current-value {1 2 3}))
             (s3 (set-ref "S3" s3decl))

             (s4decl (set-declaration-node
                      "S4"
                      :value {1 2 3 4}
                      :current-value {1 2 3 4}))

             (s4 (set-ref "S4" s4decl))

             (param-decl2 (parameter-declaration-node 
                           "p2" :domain {s3 s4}))
             (p2 (param-ref "p2" param-decl2))
             (node2 (set-value-of-param p2 '((1 2 3 4)
                                             (5 6 7 8)
                                             (5 6 7 8))))

             (param-decl3 (parameter-declaration-node 
                           "p3" :domain {s3 s4}))
             (p3 (param-ref "p3" param-decl3))
             (node3 (set-value-of-param p3 '((1.1 2 3    4)
                                             (5   6 7.12 8)
                                             (5   6 7    8.66))))

             )

        (bformat t "Testing generate-code for set-value-of-param with list")
        (generate-code node1 lang t) (terpri)(terpri)
        (generate-code node2 lang t) (terpri)(terpri)
        (generate-code node3 lang t) (terpri)(terpri)
        )
      #+end_src
**** data-section
***** description
      The code generation for the data section consists on adding the word data and the instructions of the section.  It should be very similar to the problem class.
      
***** code
      #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
      (gcode data-section-node gmpl-language
             ("data;~2%~a~%")
             (instr))
      #+END_SRC
***** tests
     #+begin_src lisp :results none :export code :tangle src/tests.lisp
     (let* ((p1-decl (parameter-declaration-node "p"))
            (p1 (param-ref "p" p1-decl))
            (s-decl (set-declaration-node "S"))
            (s (set-ref "S" s-decl))
            (node1 (data-section))
            (set-p (set-value-of-param p1 5))
            (node2 (data-section set-p))
            (set-s (set-value-of-set s '(1 2 3)))
            (node3 (data-section set-s))
            (node4 (data-section set-p set-s))
            )
       (bformat t "Testing code generation for data section")
       (format t "Testing empty data section:~%")
       (generate-code node1 (gmpl-language) t) (terpri)
       (format t "Testing data section with a param:~%")
       (generate-code node2 (gmpl-language) t) (terpri)
       (format t "Testing data section with a set:~%")
       (generate-code node3 (gmpl-language) t) (terpri)
       (format t "Testing data section with a set and a param:~%")
       (generate-code node4 (gmpl-language) t) (terpri)
       )

     #+end_src


** TODO writer-latex


** TODO writer-pulp


* Discarded stuff                                                  :noexport:
** function format-params-values-as-list
*** code
    #+BEGIN_SRC lisp +n -r :results none :exports none :tangle src/writer-gmpl.lisp
    (defun format-params-values-as-list (param value lang stream)
      "This function sets the param value for a give parameter in GMPL."
      (let* ((current-domain (domain param))
             ;; let's compute the length of `param name :='
             (name-length (length (name param)))
             (indentation (cl:+ 9 name-length))
             (indentation-str (make-string indentation
                                           :initial-element #\SPACE)))

        (let* ((domain-value (value (first current-domain)))
               (max-name-length (loop for e in domain-value
                                      maximizing (length (name e))))
               (column-for-value max-name-length))
          ;; check that the value and the domain have the same
          ;; cardinality
          (if (/= (length domain-value)
                  (length value))
              (error "Error in set-value-of-param: Parameter value and domain set should have the same number of elements."))
          ;; everything is ok, so
          ;; let's print the first two elements:
          (format stream "~a"
                  (with-output-to-string (s)
                    (format s "~a~vT~a, ~a"
                            (gcodenil-exp (first domain-value))
                            (1+ column-for-value)
                            (gcodenil-exp (first value))
                            ;; debug
                            (1+ column-for-value)
                            ;; max-name-length
                            )
                    (loop for index-value in (rest domain-value)
                          for param-value in (rest value)
                          do (format s "~%")
                          do (format s "~a ~a~vT~a, ~a"
                                     indentation-str
                                     (gcodenil-exp index-value)
                                     (cl:+ column-for-value
                                           indentation
                                           ;; add the whitespaces? :-/
                                           2)
                                     (gcodenil-exp param-value)
                                     ;;debug
                                     (cl:+ column-for-value
                                           indentation
                                           2)
                                     )))))))
    #+END_SRC
*** tests
   #+begin_src lisp :results none :export code :tangle src/tests.lisp
   (let* ((lang (gmpl-language))
          (s (set-declaration-node "S" :value {1 2 3 }))
          (dreader +standard-data-reader+)
          (param-decl (parameter-declaration-node
                       "parametro_importante"
                       :domain {s}))
          (p1 (param-ref "parametro_importante" param-decl))
          (node1 (set-value-of-param p1 {10 20 30})))

     (bformat t "Testing format-params-values-as-list")
     (format-params-values-as-list p1 {10 20 30} lang t)
  
     )
   #+end_src
   
** defun-cs
*** description
    The idea is to have a defun that also creates the case sensitive version of the function.

    For instance, we could have something like:

    (defun-cs hello (x)
      `(hello ,x))

    And it expands into:

    (progn

       (defun HELLO (x)
         `(hello ,x))

       (defun |hello| (x)
         `(HELLO x)))
*** code
    #+begin_src lisp :results none :export code
    (defmacro defun-cs (name (&rest lambda-list) @body body)
      `(progn
         (defun ,name (,@lambda-list) ,@body)

         (defun ,[]))
      )
    #+end_src
